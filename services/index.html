<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>phc.services API documentation</title>
<meta name="description" content="Contains services for accessing different parts of the PHC platform." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em;font-family:"Lato",Helvetica,Roboto,Arial,"Lucida Grande",sans-serif}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:90%}ul li code a{font-size:80%}a{color:#00539a;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#f7944d}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" href="./favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phc.services</code></h1>
</header>
<section id="section-intro">
<p>Contains services for accessing different parts of the PHC platform.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains services for accessing different parts of the PHC platform.
&#34;&#34;&#34;

from phc.services.accounts import Accounts
from phc.services.analytics import Analytics
from phc.services.fhir import Fhir
from phc.services.projects import Projects
from phc.services.files import Files
from phc.services.cohorts import Cohorts
from phc.services.genomics import Genomics
from phc.services.tools import Tools
from phc.services.workflows import Workflows


__all__ = [
    &#34;Accounts&#34;,
    &#34;Analytics&#34;,
    &#34;Fhir&#34;,
    &#34;Projects&#34;,
    &#34;Files&#34;,
    &#34;Cohorts&#34;,
    &#34;Genomics&#34;,
    &#34;Tools&#34;,
    &#34;Workflows&#34;,
]

__pdoc__ = {
    &#34;accounts&#34;: False,
    &#34;analytics&#34;: False,
    &#34;fhir&#34;: False,
    &#34;projects&#34;: False,
    &#34;files&#34;: False,
    &#34;cohorts&#34;: False,
    &#34;genomics&#34;: False,
    &#34;tools&#34;: False,
    &#34;workflows&#34;: False,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phc.services.Accounts"><code class="flex name class">
<span>class <span class="ident">Accounts</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC accounts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Accounts(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC accounts

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def get_list(self) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetches the list of accounts for the current session

        Returns
        -------
        phc.ApiResponse
            The list accounts response
        &#34;&#34;&#34;
        return self._api_call(&#34;accounts&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Accounts.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches the list of accounts for the current session</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list accounts response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(self) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetches the list of accounts for the current session

    Returns
    -------
    phc.ApiResponse
        The list accounts response
    &#34;&#34;&#34;
    return self._api_call(&#34;accounts&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Analytics"><code class="flex name class">
<span>class <span class="ident">Analytics</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC Analytics and Data Lake</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Analytics(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC Analytics and Data Lake

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def execute_sql(
        self, statement: str, project_id: str = None, cohort_id: str = None
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a SQL query against Analytics

        Parameters
        ----------
        project_id : str
            The project ID
        cohort_id : str
            The cohort ID
        statement : str
            The SQL statement

        Returns
        -------
        ApiResponse
            The API Response

        Raises
        ------
        ValueError
            If no project or cohort ID is provided

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Analytics
        &gt;&gt;&gt; client = Analytics(session)
        &gt;&gt;&gt; res = client.execute_sql(cohort_id=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, statement=&#39;SELECT patients from patient&#39;)
        &gt;&gt;&gt; print(f&#34;Found {len(res.get(&#39;data&#39;).get(&#39;patients&#39;))} patients&#34;)
        &#34;&#34;&#34;
        if not project_id and not cohort_id:
            raise ValueError(
                &#34;Must provide a value for the project or cohort ID&#34;
            )

        payload = {&#34;string_query&#34;: statement}

        if project_id:
            payload[&#34;dataset_id&#34;] = project_id
        if cohort_id:
            payload[&#34;cohort_id&#34;] = cohort_id

        return self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)

    def get_patients(
        self, project_id: str, query_builder: PatientFilterQueryBuilder
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a query that returns patients

        Parameters
        ----------
        project_id : str
            The project ID
        query_builder : util.PatientFilterQueryBuilder
            The query builder

        Returns
        -------
        list
            The list of patients

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Analytics
        &gt;&gt;&gt; from phc.util import PatientFilterQueryBuilder
        &gt;&gt;&gt; client = Analytics(session)
        &gt;&gt;&gt; search = PatientFilterQueryBuilder()
        &gt;&gt;&gt; search.patient() \
                .observations() \
                .code(eq=&#39;11142-7&#39;) \
                .system(eq=&#39;http://loinc.org&#39;) \
                .value_quantity(lt=40)
        &gt;&gt;&gt; res = client.get_patients(project=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, query_builder=search)
        &gt;&gt;&gt; print(f&#34;Found {len(res)} patients&#34;)
        &#34;&#34;&#34;
        payload = query_builder.to_dict()
        payload[&#34;dataset_id&#34;] = project_id
        return (
            self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)
            .get(&#34;data&#34;)
            .get(&#34;patients&#34;)
        )

    def execute_data_lake_query(self, query: DataLakeQuery) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a data lake query

        Parameters
        ----------
        query : util.DataLakeQuery
            The query builder

        Returns
        -------
        phc.ApiResponse
            The data lake query

        Examples
        --------
        &gt;&gt;&gt; from phc import Session
        &gt;&gt;&gt; from phc.services import Analytics
        &gt;&gt;&gt; from phc.util import DataLakeQuery

        &gt;&gt;&gt; session = Session()
        &gt;&gt;&gt; client = Analytics(session)

        &gt;&gt;&gt; project_id = &#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;
        &gt;&gt;&gt; query_string = &#34;SELECT sample_id, gene, impact, amino_acid_change, histology FROM variant WHERE tumor_site=&#39;breast&#39;&#34;
        &gt;&gt;&gt; output_file_name = &#39;query-test-notebook&#39;
        &gt;&gt;&gt; query = DataLakeQuery(project_id=project_id, query=query_string, output_file_name=output_file_name)

        &gt;&gt;&gt; query_id = client.execute_data_lake_query(query)
        &gt;&gt;&gt; specific_query = client.get_data_lake_query(query_id)
        &gt;&gt;&gt; paginated_dataset_queries = client.list_data_lake_queries(project_id)
        &gt;&gt;&gt; print(query_id)
        &#34;&#34;&#34;
        payload = query.to_request_dict()
        return self._api_call(
            &#34;analytics/data-lake/query&#34;, http_verb=&#34;POST&#34;, json=payload
        ).get(&#34;queryId&#34;)

    def list_data_lake_queries(
        self, project_id: str, page_size: int = 25, next_page_token: str = None
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetches a list of data lake queries

        Parameters
        ----------
        project_id : str
            The project ID
        page_size : int, optional
            The page size, by default 25
        next_page_token : str, optional
            The next page token, by default None

        Returns
        -------
        phc.ApiResponse
            The data lake list query response
        &#34;&#34;&#34;
        path = &#34;analytics/data-lake/query?datasetId=%s&amp;pageSize=%d&#34; % (
            project_id,
            page_size,
        )
        if next_page_token:
            path = &#34;%s&amp;nextPageToken=%s&#34; % (path, next_page_token)
        return self._api_call(path, http_verb=&#34;GET&#34;)

    def get_data_lake_query(self, query_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetches a data lake query

        Parameters
        ----------
        query_id : string
            The query ID

        Returns
        -------
        phc.ApiResponse
            The data lake query get response
        &#34;&#34;&#34;
        return self._api_call(
            &#34;analytics/data-lake/query/%s&#34; % query_id, http_verb=&#34;GET&#34;
        )

    def list_data_lake_schemas(self, project_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetches the data lake table schemas

        Parameters
        ----------
        project_id : string
            The dataset to fetch the table schemas of

        Returns
        -------
        phc.ApiResponse
            The schema for each data lake table
        &#34;&#34;&#34;
        path = &#34;analytics/data-lake/schema?datasetId=%s&#34; % (project_id)
        return self._api_call(path, http_verb=&#34;GET&#34;)

    def get_data_lake_schema(self, project_id: str, table: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetches the schema for a specific data lake table

        Parameters
        ----------
        project_id : string
            The dataset to fetch the table schema of

        table : string
            Name of the table

        Returns
        -------
        phc.ApiResponse
            Schema of the specified table
        &#34;&#34;&#34;
        path = &#34;analytics/data-lake/schema/%s?datasetId=%s&#34; % (
            table,
            project_id,
        )
        return self._api_call(path, http_verb=&#34;GET&#34;)

    def execute_data_lake_query_to_dataframe(
        self, query: DataLakeQuery, dest_dir: str = os.getcwd()
    ):
        &#34;&#34;&#34;Executes a data lake query, downloads the result file and converts to a Pandas dataframe.

        To use this method, the &#39;pandas&#39; module is required.
        Otherwise, an exception will be thrown.

        Parameters
        ----------
        query : util.DataLakeQuery
            The query builder

        dest_dir : string
            Directory the result file will be downloaded to.
            Defaults to the current working directory.

        Returns
        -------
        asyncio.Future || pandas.DataFrame
            A Future if run_async is True, the data lake query result contained in a Pandas dataframe otherwise.

        Examples
        --------
        &gt;&gt;&gt; from phc import Session
        &gt;&gt;&gt; from phc.services import Analytics
        &gt;&gt;&gt; from phc.util import DataLakeQuery

        &gt;&gt;&gt; session = Session()
        &gt;&gt;&gt; client = Analytics(session)

        &gt;&gt;&gt; project_id = &#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;
        &gt;&gt;&gt; query_string = &#34;SELECT sample_id, gene, impact, amino_acid_change, histology FROM variant WHERE tumor_site=&#39;breast&#39;&#34;
        &gt;&gt;&gt; output_file_name = &#39;query-dataframe-test&#39;
        &gt;&gt;&gt; query = DataLakeQuery(project_id=project_id, query=query_string, output_file_name=output_file_name)

        &gt;&gt;&gt; dataframe = client.execute_data_lake_query_to_dataframe(query)
        &gt;&gt;&gt; dataframe.head()
        &#34;&#34;&#34;
        if not _has_pandas:
            raise ImportError(&#34;pandas is required&#34;)

        future = asyncio.ensure_future(
            self.__execute_data_lake_query_to_dataframe_impl(query, dest_dir),
            loop=self._event_loop,
        )
        return (
            future
            if self.run_async
            else self._event_loop.run_until_complete(future)
        )

    def load_data_lake_result_to_dataframe(
        self, query_id: str, dest_dir: str = os.getcwd()
    ):
        &#34;&#34;&#34;Downloads the result file of a query and converts to a Pandas dataframe.

        To use this method, the &#39;pandas&#39; module is required.
        Otherwise, an exception will be thrown.

        Parameters
        ----------
        query_id : string
            Id of the query to load results from

        dest_dir : string
            Directory the result file will be downloaded to.
            Defaults to the current working directory.

        Returns
        -------
        asyncio.Future || pandas.DataFrame
            A Future if run_async is True, the data lake query result contained in a Pandas dataframe otherwise.
        &#34;&#34;&#34;
        if not _has_pandas:
            raise ImportError(&#34;pandas is required&#34;)

        future = asyncio.ensure_future(
            self.__load_data_lake_result_to_dataframe_impl(query_id, dest_dir),
            loop=self._event_loop,
        )
        return (
            future
            if self.run_async
            else self._event_loop.run_until_complete(future)
        )

    async def __execute_data_lake_query_to_dataframe_impl(
        self, query: DataLakeQuery, dest_dir: str
    ):
        &#34;&#34;&#34;Internal method for execting a data lake query, downloads the result file and converts to a Pandas dataframe.

        This method exists to support either async or synchronous execution.

        Parameters
        ----------
        query : util.DataLakeQuery
            The query builder

        dest_dir : string
            Directory the result file will be downloaded to

        Returns
        -------
        pandas.DataFrame
            The data lake query result contained in a Pandas dataframe.
        &#34;&#34;&#34;
        analytics_client = (
            Analytics(
                self.session,
                run_async=False,
                timeout=self.timeout,
                trust_env=self.trust_env,
            )
            if self.run_async
            else self
        )
        query_id = analytics_client.execute_data_lake_query(query)

        if not self.__poll_predicate(
            self.__data_lake_query_predicate, 3600, analytics_client, query_id
        ):
            raise RuntimeError(
                f&#34;Timed out waiting for query {query_id} to complete&#34;
            )

        return await self.__load_data_lake_result_to_dataframe_impl(
            query_id, dest_dir
        )

    async def __load_data_lake_result_to_dataframe_impl(
        self, query_id: str, dest_dir: str
    ):
        &#34;&#34;&#34;Internal method for loading an existing data lake query result to a Pandas dataframe.

        This method exists to support either async or synchronous execution.

        Parameters
        ----------
        query_id : string
            Id of the query to load results from

        dest_dir : string
            Directory the result file will be downloaded to

        Returns
        -------
        pandas.DataFrame
            The data lake query result contained in a Pandas dataframe.
        &#34;&#34;&#34;
        analytics_client = (
            Analytics(
                self.session,
                run_async=False,
                timeout=self.timeout,
                trust_env=self.trust_env,
            )
            if self.run_async
            else self
        )
        analytics_client.get_data_lake_query(
            query_id
        )  # verify the query exists, an exception will be thrown if it does not

        files_client = files.Files(
            self.session,
            run_async=False,
            timeout=self.timeout,
            trust_env=self.trust_env,
        )
        if not self.__poll_predicate(files_client.exists, 30, query_id):
            raise RuntimeError(
                f&#34;Timed out waiting for result file {query_id} to become available&#34;
            )

        download_path = files_client.download(query_id, dest_dir=dest_dir)
        return _pd.read_csv(download_path)

    def __data_lake_query_predicate(self, analytics_client, query_id):
        &#34;&#34;&#34;Checks if a query has completed successfully.

        If the query was cancelled or failed an exception will be thrown.

        Parameters
        ----------
        analytics_client : phc.services.Analytics
            Instance of the Analytics client

        query_id : string
            Id of the query to check for completion

        Returns
        -------
        bool
            True if the query is in the &#39;succeeded&#39; state, False if &#39;running&#39;.
        &#34;&#34;&#34;
        response = analytics_client.get_data_lake_query(query_id)
        state = response.get(&#34;state&#34;)

        if state == &#34;failed&#34; or state == &#34;cancelled&#34;:
            raise RuntimeError(f&#34;Query {query_id} is {state}&#34;)
        return state == &#34;succeeded&#34;

    def __poll_predicate(self, predicate, timeout_sec, *args, **kwargs):
        &#34;&#34;&#34;Executes a function until it returns a truthy value or the timeout is reached.

        This method will wait 2 seconds between predicate function executions.

        Parameters
        ----------
        predicate : function
            Function to invoke until it returns a truthy value

        timeout_sec : int
            The number of seconds to wait until timing out

        args : list
            The positional args to invoke the predicate function with

        kwargs : dict
            The keyword args to invoke the predicate function with
        Returns
        -------
        bool
            True if the function evaluated to True, False otherwise.
        &#34;&#34;&#34;
        timeout_time = time.time() + timeout_sec
        while timeout_time &gt; time.time():
            if predicate(*args, **kwargs):
                return True
            time.sleep(2)
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Analytics.execute_data_lake_query"><code class="name flex">
<span>def <span class="ident">execute_data_lake_query</span></span>(<span>self, query: phc.util.data_lake_query.DataLakeQuery) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a data lake query</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>util.DataLakeQuery</code></dt>
<dd>The query builder</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The data lake query</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc import Session
&gt;&gt;&gt; from phc.services import Analytics
&gt;&gt;&gt; from phc.util import DataLakeQuery
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; session = Session()
&gt;&gt;&gt; client = Analytics(session)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; project_id = '19e34782-91c4-4143-aaee-2ba81ed0b206'
&gt;&gt;&gt; query_string = &quot;SELECT sample_id, gene, impact, amino_acid_change, histology FROM variant WHERE tumor_site='breast'&quot;
&gt;&gt;&gt; output_file_name = 'query-test-notebook'
&gt;&gt;&gt; query = DataLakeQuery(project_id=project_id, query=query_string, output_file_name=output_file_name)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; query_id = client.execute_data_lake_query(query)
&gt;&gt;&gt; specific_query = client.get_data_lake_query(query_id)
&gt;&gt;&gt; paginated_dataset_queries = client.list_data_lake_queries(project_id)
&gt;&gt;&gt; print(query_id)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_data_lake_query(self, query: DataLakeQuery) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a data lake query

    Parameters
    ----------
    query : util.DataLakeQuery
        The query builder

    Returns
    -------
    phc.ApiResponse
        The data lake query

    Examples
    --------
    &gt;&gt;&gt; from phc import Session
    &gt;&gt;&gt; from phc.services import Analytics
    &gt;&gt;&gt; from phc.util import DataLakeQuery

    &gt;&gt;&gt; session = Session()
    &gt;&gt;&gt; client = Analytics(session)

    &gt;&gt;&gt; project_id = &#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;
    &gt;&gt;&gt; query_string = &#34;SELECT sample_id, gene, impact, amino_acid_change, histology FROM variant WHERE tumor_site=&#39;breast&#39;&#34;
    &gt;&gt;&gt; output_file_name = &#39;query-test-notebook&#39;
    &gt;&gt;&gt; query = DataLakeQuery(project_id=project_id, query=query_string, output_file_name=output_file_name)

    &gt;&gt;&gt; query_id = client.execute_data_lake_query(query)
    &gt;&gt;&gt; specific_query = client.get_data_lake_query(query_id)
    &gt;&gt;&gt; paginated_dataset_queries = client.list_data_lake_queries(project_id)
    &gt;&gt;&gt; print(query_id)
    &#34;&#34;&#34;
    payload = query.to_request_dict()
    return self._api_call(
        &#34;analytics/data-lake/query&#34;, http_verb=&#34;POST&#34;, json=payload
    ).get(&#34;queryId&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.execute_data_lake_query_to_dataframe"><code class="name flex">
<span>def <span class="ident">execute_data_lake_query_to_dataframe</span></span>(<span>self, query: phc.util.data_lake_query.DataLakeQuery, dest_dir: str = '/home/runner/work/phc-sdk-py/phc-sdk-py')</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a data lake query, downloads the result file and converts to a Pandas dataframe.</p>
<p>To use this method, the 'pandas' module is required.
Otherwise, an exception will be thrown.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>query</code></strong> :&ensp;<code>util.DataLakeQuery</code></dt>
<dd>The query builder</dd>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>string</code></dt>
<dd>Directory the result file will be downloaded to.
Defaults to the current working directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>asyncio.Future || pandas.DataFrame</code></dt>
<dd>A Future if run_async is True, the data lake query result contained in a Pandas dataframe otherwise.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc import Session
&gt;&gt;&gt; from phc.services import Analytics
&gt;&gt;&gt; from phc.util import DataLakeQuery
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; session = Session()
&gt;&gt;&gt; client = Analytics(session)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; project_id = '19e34782-91c4-4143-aaee-2ba81ed0b206'
&gt;&gt;&gt; query_string = &quot;SELECT sample_id, gene, impact, amino_acid_change, histology FROM variant WHERE tumor_site='breast'&quot;
&gt;&gt;&gt; output_file_name = 'query-dataframe-test'
&gt;&gt;&gt; query = DataLakeQuery(project_id=project_id, query=query_string, output_file_name=output_file_name)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; dataframe = client.execute_data_lake_query_to_dataframe(query)
&gt;&gt;&gt; dataframe.head()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_data_lake_query_to_dataframe(
    self, query: DataLakeQuery, dest_dir: str = os.getcwd()
):
    &#34;&#34;&#34;Executes a data lake query, downloads the result file and converts to a Pandas dataframe.

    To use this method, the &#39;pandas&#39; module is required.
    Otherwise, an exception will be thrown.

    Parameters
    ----------
    query : util.DataLakeQuery
        The query builder

    dest_dir : string
        Directory the result file will be downloaded to.
        Defaults to the current working directory.

    Returns
    -------
    asyncio.Future || pandas.DataFrame
        A Future if run_async is True, the data lake query result contained in a Pandas dataframe otherwise.

    Examples
    --------
    &gt;&gt;&gt; from phc import Session
    &gt;&gt;&gt; from phc.services import Analytics
    &gt;&gt;&gt; from phc.util import DataLakeQuery

    &gt;&gt;&gt; session = Session()
    &gt;&gt;&gt; client = Analytics(session)

    &gt;&gt;&gt; project_id = &#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;
    &gt;&gt;&gt; query_string = &#34;SELECT sample_id, gene, impact, amino_acid_change, histology FROM variant WHERE tumor_site=&#39;breast&#39;&#34;
    &gt;&gt;&gt; output_file_name = &#39;query-dataframe-test&#39;
    &gt;&gt;&gt; query = DataLakeQuery(project_id=project_id, query=query_string, output_file_name=output_file_name)

    &gt;&gt;&gt; dataframe = client.execute_data_lake_query_to_dataframe(query)
    &gt;&gt;&gt; dataframe.head()
    &#34;&#34;&#34;
    if not _has_pandas:
        raise ImportError(&#34;pandas is required&#34;)

    future = asyncio.ensure_future(
        self.__execute_data_lake_query_to_dataframe_impl(query, dest_dir),
        loop=self._event_loop,
    )
    return (
        future
        if self.run_async
        else self._event_loop.run_until_complete(future)
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.execute_sql"><code class="name flex">
<span>def <span class="ident">execute_sql</span></span>(<span>self, statement: str, project_id: str = None, cohort_id: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a SQL query against Analytics</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>cohort_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort ID</dd>
<dt><strong><code>statement</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL statement</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The API Response</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no project or cohort ID is provided</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Analytics
&gt;&gt;&gt; client = Analytics(session)
&gt;&gt;&gt; res = client.execute_sql(cohort_id='5a07dedb-fa2a-4cb0-b662-95b23a050221', statement='SELECT patients from patient')
&gt;&gt;&gt; print(f&quot;Found {len(res.get('data').get('patients'))} patients&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_sql(
    self, statement: str, project_id: str = None, cohort_id: str = None
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a SQL query against Analytics

    Parameters
    ----------
    project_id : str
        The project ID
    cohort_id : str
        The cohort ID
    statement : str
        The SQL statement

    Returns
    -------
    ApiResponse
        The API Response

    Raises
    ------
    ValueError
        If no project or cohort ID is provided

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Analytics
    &gt;&gt;&gt; client = Analytics(session)
    &gt;&gt;&gt; res = client.execute_sql(cohort_id=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, statement=&#39;SELECT patients from patient&#39;)
    &gt;&gt;&gt; print(f&#34;Found {len(res.get(&#39;data&#39;).get(&#39;patients&#39;))} patients&#34;)
    &#34;&#34;&#34;
    if not project_id and not cohort_id:
        raise ValueError(
            &#34;Must provide a value for the project or cohort ID&#34;
        )

    payload = {&#34;string_query&#34;: statement}

    if project_id:
        payload[&#34;dataset_id&#34;] = project_id
    if cohort_id:
        payload[&#34;cohort_id&#34;] = cohort_id

    return self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.get_data_lake_query"><code class="name flex">
<span>def <span class="ident">get_data_lake_query</span></span>(<span>self, query_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches a data lake query</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>query_id</code></strong> :&ensp;<code>string</code></dt>
<dd>The query ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The data lake query get response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_lake_query(self, query_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetches a data lake query

    Parameters
    ----------
    query_id : string
        The query ID

    Returns
    -------
    phc.ApiResponse
        The data lake query get response
    &#34;&#34;&#34;
    return self._api_call(
        &#34;analytics/data-lake/query/%s&#34; % query_id, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.get_data_lake_schema"><code class="name flex">
<span>def <span class="ident">get_data_lake_schema</span></span>(<span>self, project_id: str, table: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches the schema for a specific data lake table</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>string</code></dt>
<dd>The dataset to fetch the table schema of</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>Schema of the specified table</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_lake_schema(self, project_id: str, table: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetches the schema for a specific data lake table

    Parameters
    ----------
    project_id : string
        The dataset to fetch the table schema of

    table : string
        Name of the table

    Returns
    -------
    phc.ApiResponse
        Schema of the specified table
    &#34;&#34;&#34;
    path = &#34;analytics/data-lake/schema/%s?datasetId=%s&#34; % (
        table,
        project_id,
    )
    return self._api_call(path, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.get_patients"><code class="name flex">
<span>def <span class="ident">get_patients</span></span>(<span>self, project_id: str, query_builder: phc.util.patient_filter_query_builder.PatientFilterQueryBuilder) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a query that returns patients</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>query_builder</code></strong> :&ensp;<code>util.PatientFilterQueryBuilder</code></dt>
<dd>The query builder</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of patients</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Analytics
&gt;&gt;&gt; from phc.util import PatientFilterQueryBuilder
&gt;&gt;&gt; client = Analytics(session)
&gt;&gt;&gt; search = PatientFilterQueryBuilder()
&gt;&gt;&gt; search.patient()                 .observations()                 .code(eq='11142-7')                 .system(eq='http://loinc.org')                 .value_quantity(lt=40)
&gt;&gt;&gt; res = client.get_patients(project='5a07dedb-fa2a-4cb0-b662-95b23a050221', query_builder=search)
&gt;&gt;&gt; print(f&quot;Found {len(res)} patients&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_patients(
    self, project_id: str, query_builder: PatientFilterQueryBuilder
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a query that returns patients

    Parameters
    ----------
    project_id : str
        The project ID
    query_builder : util.PatientFilterQueryBuilder
        The query builder

    Returns
    -------
    list
        The list of patients

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Analytics
    &gt;&gt;&gt; from phc.util import PatientFilterQueryBuilder
    &gt;&gt;&gt; client = Analytics(session)
    &gt;&gt;&gt; search = PatientFilterQueryBuilder()
    &gt;&gt;&gt; search.patient() \
            .observations() \
            .code(eq=&#39;11142-7&#39;) \
            .system(eq=&#39;http://loinc.org&#39;) \
            .value_quantity(lt=40)
    &gt;&gt;&gt; res = client.get_patients(project=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, query_builder=search)
    &gt;&gt;&gt; print(f&#34;Found {len(res)} patients&#34;)
    &#34;&#34;&#34;
    payload = query_builder.to_dict()
    payload[&#34;dataset_id&#34;] = project_id
    return (
        self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)
        .get(&#34;data&#34;)
        .get(&#34;patients&#34;)
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.list_data_lake_queries"><code class="name flex">
<span>def <span class="ident">list_data_lake_queries</span></span>(<span>self, project_id: str, page_size: int = 25, next_page_token: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches a list of data lake queries</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default 25</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The data lake list query response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_data_lake_queries(
    self, project_id: str, page_size: int = 25, next_page_token: str = None
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetches a list of data lake queries

    Parameters
    ----------
    project_id : str
        The project ID
    page_size : int, optional
        The page size, by default 25
    next_page_token : str, optional
        The next page token, by default None

    Returns
    -------
    phc.ApiResponse
        The data lake list query response
    &#34;&#34;&#34;
    path = &#34;analytics/data-lake/query?datasetId=%s&amp;pageSize=%d&#34; % (
        project_id,
        page_size,
    )
    if next_page_token:
        path = &#34;%s&amp;nextPageToken=%s&#34; % (path, next_page_token)
    return self._api_call(path, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.list_data_lake_schemas"><code class="name flex">
<span>def <span class="ident">list_data_lake_schemas</span></span>(<span>self, project_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches the data lake table schemas</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>string</code></dt>
<dd>The dataset to fetch the table schemas of</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The schema for each data lake table</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_data_lake_schemas(self, project_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetches the data lake table schemas

    Parameters
    ----------
    project_id : string
        The dataset to fetch the table schemas of

    Returns
    -------
    phc.ApiResponse
        The schema for each data lake table
    &#34;&#34;&#34;
    path = &#34;analytics/data-lake/schema?datasetId=%s&#34; % (project_id)
    return self._api_call(path, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.load_data_lake_result_to_dataframe"><code class="name flex">
<span>def <span class="ident">load_data_lake_result_to_dataframe</span></span>(<span>self, query_id: str, dest_dir: str = '/home/runner/work/phc-sdk-py/phc-sdk-py')</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads the result file of a query and converts to a Pandas dataframe.</p>
<p>To use this method, the 'pandas' module is required.
Otherwise, an exception will be thrown.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>query_id</code></strong> :&ensp;<code>string</code></dt>
<dd>Id of the query to load results from</dd>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>string</code></dt>
<dd>Directory the result file will be downloaded to.
Defaults to the current working directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>asyncio.Future || pandas.DataFrame</code></dt>
<dd>A Future if run_async is True, the data lake query result contained in a Pandas dataframe otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data_lake_result_to_dataframe(
    self, query_id: str, dest_dir: str = os.getcwd()
):
    &#34;&#34;&#34;Downloads the result file of a query and converts to a Pandas dataframe.

    To use this method, the &#39;pandas&#39; module is required.
    Otherwise, an exception will be thrown.

    Parameters
    ----------
    query_id : string
        Id of the query to load results from

    dest_dir : string
        Directory the result file will be downloaded to.
        Defaults to the current working directory.

    Returns
    -------
    asyncio.Future || pandas.DataFrame
        A Future if run_async is True, the data lake query result contained in a Pandas dataframe otherwise.
    &#34;&#34;&#34;
    if not _has_pandas:
        raise ImportError(&#34;pandas is required&#34;)

    future = asyncio.ensure_future(
        self.__load_data_lake_result_to_dataframe_impl(query_id, dest_dir),
        loop=self._event_loop,
    )
    return (
        future
        if self.run_async
        else self._event_loop.run_until_complete(future)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Cohorts"><code class="flex name class">
<span>class <span class="ident">Cohorts</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC cohorts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cohorts(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC cohorts

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def create(
        self, project_id: str, name: str, queries: list, description: str = None
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a cohort

        Parameters
        ----------
        project_id: str
            The project that owns the cohort
        name : str
            The cohort name.
        queries: list
            The list of queries that define the cohort
        description : str, optional
            The cohort description, by default None

        Returns
        -------
        phc.ApiResponse
            The create cohort response
        &#34;&#34;&#34;
        json_body = {
            &#34;name&#34;: name,
            &#34;ownerProject&#34;: project_id,
            &#34;queries&#34;: queries,
        }
        if description:
            json_body[&#34;description&#34;] = description
        return self._api_call(&#34;cohorts&#34;, json=json_body, http_verb=&#34;POST&#34;)

    def get(self, cohort_id) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a cohort by id

        Parameters
        ----------
        cohort_id : str
            The cohort ID.

        Returns
        -------
        phc.ApiResponse
            The get cohort response
        &#34;&#34;&#34;
        return self._api_call(f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;GET&#34;)

    def delete(self, cohort_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a cohort

        Parameters
        ----------
        cohort_id : str
            The cohort ID.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._api_call(
                f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 204
        )

    def get_list(
        self,
        project_id: str,
        page_size: int = None,
        next_page_token: str = None,
        name: str = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of cohorts in a project

        Parameters
        ----------
        project_id: str
            The project ID to search within
        page_size : int, optional
            The page size, by default None
        next_page_token : str, optional
            The next page token, by default None
        name : str, optional
            A cohort name filter, by default None

        Returns
        -------
        phc.ApiResponse
            The list cohorts response
        &#34;&#34;&#34;
        query_dict = {&#34;projectId&#34;: project_id}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if name:
            query_dict[&#34;name&#34;] = name
        return self._api_call(
            f&#34;cohorts?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Cohorts.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, project_id: str, name: str, queries: list, description: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a cohort</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project that owns the cohort</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort name.</dd>
<dt><strong><code>queries</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of queries that define the cohort</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The cohort description, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The create cohort response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(
    self, project_id: str, name: str, queries: list, description: str = None
) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a cohort

    Parameters
    ----------
    project_id: str
        The project that owns the cohort
    name : str
        The cohort name.
    queries: list
        The list of queries that define the cohort
    description : str, optional
        The cohort description, by default None

    Returns
    -------
    phc.ApiResponse
        The create cohort response
    &#34;&#34;&#34;
    json_body = {
        &#34;name&#34;: name,
        &#34;ownerProject&#34;: project_id,
        &#34;queries&#34;: queries,
    }
    if description:
        json_body[&#34;description&#34;] = description
    return self._api_call(&#34;cohorts&#34;, json=json_body, http_verb=&#34;POST&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Cohorts.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, cohort_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a cohort</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cohort_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, cohort_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a cohort

    Parameters
    ----------
    cohort_id : str
        The cohort ID.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._api_call(
            f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Cohorts.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, cohort_id) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a cohort by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cohort_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get cohort response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, cohort_id) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a cohort by id

    Parameters
    ----------
    cohort_id : str
        The cohort ID.

    Returns
    -------
    phc.ApiResponse
        The get cohort response
    &#34;&#34;&#34;
    return self._api_call(f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Cohorts.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, project_id: str, page_size: int = None, next_page_token: str = None, name: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of cohorts in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to search within</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A cohort name filter, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list cohorts response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    project_id: str,
    page_size: int = None,
    next_page_token: str = None,
    name: str = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of cohorts in a project

    Parameters
    ----------
    project_id: str
        The project ID to search within
    page_size : int, optional
        The page size, by default None
    next_page_token : str, optional
        The next page token, by default None
    name : str, optional
        A cohort name filter, by default None

    Returns
    -------
    phc.ApiResponse
        The list cohorts response
    &#34;&#34;&#34;
    query_dict = {&#34;projectId&#34;: project_id}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if name:
        query_dict[&#34;name&#34;] = name
    return self._api_call(
        f&#34;cohorts?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Fhir"><code class="flex name class">
<span>class <span class="ident">Fhir</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides bindings to the LifeOmic FHIR Service APIs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fhir(BaseClient):
    &#34;&#34;&#34;Provides bindings to the LifeOmic FHIR Service APIs&#34;&#34;&#34;

    def dsl(self, project: str, data: dict, scroll=&#34;&#34;):
        &#34;&#34;&#34;Executes a LifeOmic FHIR Service DSL request

        Parameters
        ----------
        project : str
            The target LifeOmic project identifier
        data : dict
            The DSL request object
        scroll
            The scroll request parameter

        Returns
        -------
        phc.ApiResponse
            The API response
        &#34;&#34;&#34;
        path = f&#34;fhir-search/projects/{project}&#34;
        scroll = scroll if scroll is not True else &#34;true&#34;
        params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
        return self._api_call(
            http_verb=&#34;POST&#34;, api_path=path, params=params, json=data
        )

    def sql(self, project: str, statement: str, scroll=&#34;&#34;) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a LifeOmic FHIR Service SQL request

        Parameters
        ----------
        project : str
            The target LifeOmic project identifier
        statement : str
            The SQL request statement
        scroll
            The scroll request parameter

        Returns
        -------
        phc.ApiResponse
            The API response
        &#34;&#34;&#34;
        path = f&#34;fhir-search/projects/{project}&#34;
        headers = {&#34;Content-Type&#34;: &#34;text/plain&#34;}
        params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
        return self._api_call(
            http_verb=&#34;POST&#34;,
            api_path=path,
            headers=headers,
            params=params,
            data=statement,
        )

    def execute_sql(
        self, project_id: str, statement: str, scroll=&#34;&#34;
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes an SQL query against fhir-searh-service

        Parameters
        ----------
        project_id : str
            The project ID.
        statement : str
            The SQL statement.

        Returns
        -------
        phc.ApiResponse
            The query response.

        Examples
        --------
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from phc.services import Fhir
        &gt;&gt;&gt; fhir = Fhir(session)
        &gt;&gt;&gt; res = fhir.execute_sql(project_id=&#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;,
                       statement=&#39;SELECT * from patient LIMIT 0,5000&#39;)

        &gt;&gt;&gt; resources = list(map(lambda r: r.get(&#34;_source&#34;), res.get(&#34;hits&#34;).get(&#34;hits&#34;)))
        &gt;&gt;&gt; df = pd.DataFrame(resources)
        &#34;&#34;&#34;

        &#34;&#34;&#34;Executes an SQL query against fhir-searh-service
        Returns:
            [List] -- Dictionary with query response
        &#34;&#34;&#34;
        warnings.warn(&#34;Use the sql method instead&#34;, DeprecationWarning)
        return self._api_call(
            api_path=f&#34;fhir-search/projects/{project_id}&#34;,
            http_verb=&#34;POST&#34;,
            data=statement,
            headers={&#34;Content-Type&#34;: &#34;text/plain&#34;},
            params={&#34;scroll&#34;: scroll},
        )

    def execute_es(
        self, project_id: str, query: dict, scroll=&#34;&#34;
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes an elasticsearch query against fhir-searh-service

        Parameters
        ----------
        project_id : str
            The project ID
        query : dict
            The ES query dictionary

        Returns
        -------
        phc.ApiResponse
            The query response
        &#34;&#34;&#34;
        warnings.warn(&#34;Use the dsl method instead&#34;, DeprecationWarning)
        return self._api_call(
            api_path=f&#34;fhir-search/projects/{project_id}&#34;,
            http_verb=&#34;POST&#34;,
            json=query,
            params={&#34;scroll&#34;: scroll},
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Fhir.dsl"><code class="name flex">
<span>def <span class="ident">dsl</span></span>(<span>self, project: str, data: dict, scroll='')</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a LifeOmic FHIR Service DSL request</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code></dt>
<dd>The target LifeOmic project identifier</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>The DSL request object</dd>
<dt><strong><code>scroll</code></strong></dt>
<dd>The scroll request parameter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The API response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dsl(self, project: str, data: dict, scroll=&#34;&#34;):
    &#34;&#34;&#34;Executes a LifeOmic FHIR Service DSL request

    Parameters
    ----------
    project : str
        The target LifeOmic project identifier
    data : dict
        The DSL request object
    scroll
        The scroll request parameter

    Returns
    -------
    phc.ApiResponse
        The API response
    &#34;&#34;&#34;
    path = f&#34;fhir-search/projects/{project}&#34;
    scroll = scroll if scroll is not True else &#34;true&#34;
    params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
    return self._api_call(
        http_verb=&#34;POST&#34;, api_path=path, params=params, json=data
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Fhir.execute_es"><code class="name flex">
<span>def <span class="ident">execute_es</span></span>(<span>self, project_id: str, query: dict, scroll='') ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes an elasticsearch query against fhir-searh-service</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>query</code></strong> :&ensp;<code>dict</code></dt>
<dd>The ES query dictionary</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The query response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_es(
    self, project_id: str, query: dict, scroll=&#34;&#34;
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes an elasticsearch query against fhir-searh-service

    Parameters
    ----------
    project_id : str
        The project ID
    query : dict
        The ES query dictionary

    Returns
    -------
    phc.ApiResponse
        The query response
    &#34;&#34;&#34;
    warnings.warn(&#34;Use the dsl method instead&#34;, DeprecationWarning)
    return self._api_call(
        api_path=f&#34;fhir-search/projects/{project_id}&#34;,
        http_verb=&#34;POST&#34;,
        json=query,
        params={&#34;scroll&#34;: scroll},
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Fhir.execute_sql"><code class="name flex">
<span>def <span class="ident">execute_sql</span></span>(<span>self, project_id: str, statement: str, scroll='') ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes an SQL query against fhir-searh-service</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID.</dd>
<dt><strong><code>statement</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The query response.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from phc.services import Fhir
&gt;&gt;&gt; fhir = Fhir(session)
&gt;&gt;&gt; res = fhir.execute_sql(project_id='19e34782-91c4-4143-aaee-2ba81ed0b206',
               statement='SELECT * from patient LIMIT 0,5000')
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; resources = list(map(lambda r: r.get(&quot;_source&quot;), res.get(&quot;hits&quot;).get(&quot;hits&quot;)))
&gt;&gt;&gt; df = pd.DataFrame(resources)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_sql(
    self, project_id: str, statement: str, scroll=&#34;&#34;
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes an SQL query against fhir-searh-service

    Parameters
    ----------
    project_id : str
        The project ID.
    statement : str
        The SQL statement.

    Returns
    -------
    phc.ApiResponse
        The query response.

    Examples
    --------
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from phc.services import Fhir
    &gt;&gt;&gt; fhir = Fhir(session)
    &gt;&gt;&gt; res = fhir.execute_sql(project_id=&#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;,
                   statement=&#39;SELECT * from patient LIMIT 0,5000&#39;)

    &gt;&gt;&gt; resources = list(map(lambda r: r.get(&#34;_source&#34;), res.get(&#34;hits&#34;).get(&#34;hits&#34;)))
    &gt;&gt;&gt; df = pd.DataFrame(resources)
    &#34;&#34;&#34;

    &#34;&#34;&#34;Executes an SQL query against fhir-searh-service
    Returns:
        [List] -- Dictionary with query response
    &#34;&#34;&#34;
    warnings.warn(&#34;Use the sql method instead&#34;, DeprecationWarning)
    return self._api_call(
        api_path=f&#34;fhir-search/projects/{project_id}&#34;,
        http_verb=&#34;POST&#34;,
        data=statement,
        headers={&#34;Content-Type&#34;: &#34;text/plain&#34;},
        params={&#34;scroll&#34;: scroll},
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Fhir.sql"><code class="name flex">
<span>def <span class="ident">sql</span></span>(<span>self, project: str, statement: str, scroll='') ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a LifeOmic FHIR Service SQL request</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code></dt>
<dd>The target LifeOmic project identifier</dd>
<dt><strong><code>statement</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL request statement</dd>
<dt><strong><code>scroll</code></strong></dt>
<dd>The scroll request parameter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The API response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sql(self, project: str, statement: str, scroll=&#34;&#34;) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a LifeOmic FHIR Service SQL request

    Parameters
    ----------
    project : str
        The target LifeOmic project identifier
    statement : str
        The SQL request statement
    scroll
        The scroll request parameter

    Returns
    -------
    phc.ApiResponse
        The API response
    &#34;&#34;&#34;
    path = f&#34;fhir-search/projects/{project}&#34;
    headers = {&#34;Content-Type&#34;: &#34;text/plain&#34;}
    params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
    return self._api_call(
        http_verb=&#34;POST&#34;,
        api_path=path,
        headers=headers,
        params=params,
        data=statement,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Files"><code class="flex name class">
<span>class <span class="ident">Files</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Files(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC files

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    _MULTIPART_MIN_SIZE = 5 * 1024 * 1024
    _MAX_PARTS = 10000

    def upload(
        self,
        project_id: str,
        source: str,
        file_name: str = None,
        overwrite: bool = False,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Upload a file.

        Parameters
        ----------
        project_id : str
            The project ID
        source : str
            The path of the file to upload
        file_name : str, optional
            The name of the file, If None will default to the actual base file name.
        overwrite : bool, optional
            True to overwrite an existing file of the same name, by default False

        Returns
        -------
        ApiResponse
            The upload file response

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Files
        &gt;&gt;&gt; files = files(session)
        &gt;&gt;&gt; files.upload(project_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, source=&#34;./myfile.txt&#34;, overwrite=True)
        &#34;&#34;&#34;
        file_size = os.path.getsize(source)
        if file_size &gt; self._MULTIPART_MIN_SIZE:
            res = self._api_call(
                &#34;uploads&#34;,
                json={
                    &#34;name&#34;: file_name
                    if file_name is not None
                    else os.path.basename(source),
                    &#34;datasetId&#34;: project_id,
                    &#34;overwrite&#34;: overwrite,
                },
            )
            upload_id = res.get(&#34;uploadId&#34;)
            part_size = max(
                math.ceil(file_size / self._MAX_PARTS), self._MULTIPART_MIN_SIZE
            )
            total_parts = math.ceil(file_size / part_size)
            part = 1
            while part &lt;= total_parts:
                start = (part - 1) * part_size
                end = file_size if part == total_parts else start + part_size
                f = open(source, &#34;rb&#34;)
                f.seek(start)
                data = f.read(end - start)
                f.close()
                part_res = self._api_call(
                    f&#34;uploads/{upload_id}/parts/{part}&#34;, http_verb=&#34;GET&#34;
                )
                self._api_call_impl(
                    http_verb=&#34;PUT&#34;,
                    url=part_res.get(&#34;uploadUrl&#34;),
                    api_path=None,
                    upload_file=data,
                    headers={
                        &#34;Content-Length&#34;: str(end - start),
                        &#34;Authorization&#34;: None,
                        &#34;LifeOmic-Account&#34;: None,
                        &#34;Content-Type&#34;: None,
                    },
                )
                print(f&#34;Upload {part}&#34;)
                part += 1
            self._api_call(f&#34;uploads/{upload_id}&#34;, http_verb=&#34;DELETE&#34;)
            return res
        else:
            res = self._api_call(
                &#34;files&#34;,
                json={
                    &#34;name&#34;: file_name
                    if file_name is not None
                    else os.path.basename(source),
                    &#34;datasetId&#34;: project_id,
                    &#34;overwrite&#34;: overwrite,
                },
            )
            self._api_call_impl(
                http_verb=&#34;PUT&#34;,
                url=res.get(&#34;uploadUrl&#34;),
                api_path=None,
                upload_file=source,
                headers={
                    &#34;Content-Length&#34;: str(file_size),
                    &#34;Authorization&#34;: None,
                    &#34;LifeOmic-Account&#34;: None,
                    &#34;Content-Type&#34;: None,
                },
            )
            return res

    @backoff.on_exception(
        backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
    )
    def download(self, file_id: str, dest_dir: str = os.getcwd()) -&gt; None:
        &#34;&#34;&#34;Download a file

        Parameters
        ----------
        file_id : str
            The file ID
        dest_dir : str, optional
            The local directory to save the file.  Defaults to the current working directory

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Files
        &gt;&gt;&gt; files = files(session)
        &gt;&gt;&gt; files.download(file_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
        &#34;&#34;&#34;
        res = self._api_call(
            f&#34;files/{file_id}?include=downloadUrl&#34;, http_verb=&#34;GET&#34;
        )

        file_path = os.path.join(dest_dir, res.get(&#34;name&#34;))
        target_dir = os.path.dirname(file_path)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
        return file_path

    def get(self, file_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a file by id

        Parameters
        ----------
        file_id : str
            The file ID.

        Returns
        -------
        phc.ApiResponse
            The get file response
        &#34;&#34;&#34;
        return self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)

    def update(
        self, file_id: str, project_id: str = None, name: str = None
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Update a files by moving it to a new project or by renaming it.

        Parameters
        ----------
        file_id : str
            The file ID to update.
        project_id : str
            The new project ID for the file.
        name : str
            The new file name

        Returns
        -------
        phc.ApiResponse
            The update file response
        &#34;&#34;&#34;
        if not project_id and not name:
            raise ValueError(
                &#34;Must provide a value for either &#39;project_id&#39; or &#39;name&#39;&#34;
            )

        json_body = {}
        if name:
            json_body[&#34;name&#34;] = name
        if project_id:
            json_body[&#34;datasetId&#34;] = project_id

        return self._api_call(
            f&#34;files/{file_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
        )

    def delete(self, file_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a file

        Parameters
        ----------
        file_id : str
            The file ID.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;DELETE&#34;).status_code
            == 204
        )

    def get_list(
        self,
        project_id: str,
        folder: str = None,
        page_size: int = None,
        next_page_token: str = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of files in a project

        Parameters
        ----------
        project_id: str
            The project ID
        folder: str, optional
            The folder prefix to look for files, by default None
        page_size : int, optional
            The page size, by default None
        next_page_token : str, optional
            The next page token, by default None

        Returns
        -------
        phc.ApiResponse
            The list files response
        &#34;&#34;&#34;
        query_dict = {}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if folder:
            query_dict[&#34;prefix&#34;] = folder

        return self._api_call(
            f&#34;projects/{project_id}/files?{urlencode(query_dict)}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def exists(self, file_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Check if a file exists by id

        Parameters
        ----------
        file_id : str
            The file ID.

        Returns
        -------
        bool
            True if the file exists, false otherwise
        &#34;&#34;&#34;
        try:
            self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)
            return True
        except ApiError as e:
            if e.response.status_code == 404:
                return False
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Files.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, file_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, file_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a file

    Parameters
    ----------
    file_id : str
        The file ID.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;DELETE&#34;).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Files.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, file_id: str, dest_dir: str = '/home/runner/work/phc-sdk-py/phc-sdk-py') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID</dd>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The local directory to save the file.
Defaults to the current working directory</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Files
&gt;&gt;&gt; files = files(session)
&gt;&gt;&gt; files.download(file_id=&quot;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&quot;, dest_dir=&quot;./mydata&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@backoff.on_exception(
    backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
)
def download(self, file_id: str, dest_dir: str = os.getcwd()) -&gt; None:
    &#34;&#34;&#34;Download a file

    Parameters
    ----------
    file_id : str
        The file ID
    dest_dir : str, optional
        The local directory to save the file.  Defaults to the current working directory

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Files
    &gt;&gt;&gt; files = files(session)
    &gt;&gt;&gt; files.download(file_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
    &#34;&#34;&#34;
    res = self._api_call(
        f&#34;files/{file_id}?include=downloadUrl&#34;, http_verb=&#34;GET&#34;
    )

    file_path = os.path.join(dest_dir, res.get(&#34;name&#34;))
    target_dir = os.path.dirname(file_path)
    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
    return file_path</code></pre>
</details>
</dd>
<dt id="phc.services.Files.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, file_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a file exists by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the file exists, false otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, file_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Check if a file exists by id

    Parameters
    ----------
    file_id : str
        The file ID.

    Returns
    -------
    bool
        True if the file exists, false otherwise
    &#34;&#34;&#34;
    try:
        self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)
        return True
    except ApiError as e:
        if e.response.status_code == 404:
            return False
        raise e</code></pre>
</details>
</dd>
<dt id="phc.services.Files.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, file_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a file by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get file response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, file_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a file by id

    Parameters
    ----------
    file_id : str
        The file ID.

    Returns
    -------
    phc.ApiResponse
        The get file response
    &#34;&#34;&#34;
    return self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Files.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, project_id: str, folder: str = None, page_size: int = None, next_page_token: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of files in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The folder prefix to look for files, by default None</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list files response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    project_id: str,
    folder: str = None,
    page_size: int = None,
    next_page_token: str = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of files in a project

    Parameters
    ----------
    project_id: str
        The project ID
    folder: str, optional
        The folder prefix to look for files, by default None
    page_size : int, optional
        The page size, by default None
    next_page_token : str, optional
        The next page token, by default None

    Returns
    -------
    phc.ApiResponse
        The list files response
    &#34;&#34;&#34;
    query_dict = {}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if folder:
        query_dict[&#34;prefix&#34;] = folder

    return self._api_call(
        f&#34;projects/{project_id}/files?{urlencode(query_dict)}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Files.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, file_id: str, project_id: str = None, name: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Update a files by moving it to a new project or by renaming it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID to update.</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The new project ID for the file.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The new file name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The update file response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(
    self, file_id: str, project_id: str = None, name: str = None
) -&gt; ApiResponse:
    &#34;&#34;&#34;Update a files by moving it to a new project or by renaming it.

    Parameters
    ----------
    file_id : str
        The file ID to update.
    project_id : str
        The new project ID for the file.
    name : str
        The new file name

    Returns
    -------
    phc.ApiResponse
        The update file response
    &#34;&#34;&#34;
    if not project_id and not name:
        raise ValueError(
            &#34;Must provide a value for either &#39;project_id&#39; or &#39;name&#39;&#34;
        )

    json_body = {}
    if name:
        json_body[&#34;name&#34;] = name
    if project_id:
        json_body[&#34;datasetId&#34;] = project_id

    return self._api_call(
        f&#34;files/{file_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Files.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, project_id: str, source: str, file_name: str = None, overwrite: bool = False) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Upload a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to upload</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file, If None will default to the actual base file name.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to overwrite an existing file of the same name, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The upload file response</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Files
&gt;&gt;&gt; files = files(session)
&gt;&gt;&gt; files.upload(project_id=&quot;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&quot;, source=&quot;./myfile.txt&quot;, overwrite=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(
    self,
    project_id: str,
    source: str,
    file_name: str = None,
    overwrite: bool = False,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Upload a file.

    Parameters
    ----------
    project_id : str
        The project ID
    source : str
        The path of the file to upload
    file_name : str, optional
        The name of the file, If None will default to the actual base file name.
    overwrite : bool, optional
        True to overwrite an existing file of the same name, by default False

    Returns
    -------
    ApiResponse
        The upload file response

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Files
    &gt;&gt;&gt; files = files(session)
    &gt;&gt;&gt; files.upload(project_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, source=&#34;./myfile.txt&#34;, overwrite=True)
    &#34;&#34;&#34;
    file_size = os.path.getsize(source)
    if file_size &gt; self._MULTIPART_MIN_SIZE:
        res = self._api_call(
            &#34;uploads&#34;,
            json={
                &#34;name&#34;: file_name
                if file_name is not None
                else os.path.basename(source),
                &#34;datasetId&#34;: project_id,
                &#34;overwrite&#34;: overwrite,
            },
        )
        upload_id = res.get(&#34;uploadId&#34;)
        part_size = max(
            math.ceil(file_size / self._MAX_PARTS), self._MULTIPART_MIN_SIZE
        )
        total_parts = math.ceil(file_size / part_size)
        part = 1
        while part &lt;= total_parts:
            start = (part - 1) * part_size
            end = file_size if part == total_parts else start + part_size
            f = open(source, &#34;rb&#34;)
            f.seek(start)
            data = f.read(end - start)
            f.close()
            part_res = self._api_call(
                f&#34;uploads/{upload_id}/parts/{part}&#34;, http_verb=&#34;GET&#34;
            )
            self._api_call_impl(
                http_verb=&#34;PUT&#34;,
                url=part_res.get(&#34;uploadUrl&#34;),
                api_path=None,
                upload_file=data,
                headers={
                    &#34;Content-Length&#34;: str(end - start),
                    &#34;Authorization&#34;: None,
                    &#34;LifeOmic-Account&#34;: None,
                    &#34;Content-Type&#34;: None,
                },
            )
            print(f&#34;Upload {part}&#34;)
            part += 1
        self._api_call(f&#34;uploads/{upload_id}&#34;, http_verb=&#34;DELETE&#34;)
        return res
    else:
        res = self._api_call(
            &#34;files&#34;,
            json={
                &#34;name&#34;: file_name
                if file_name is not None
                else os.path.basename(source),
                &#34;datasetId&#34;: project_id,
                &#34;overwrite&#34;: overwrite,
            },
        )
        self._api_call_impl(
            http_verb=&#34;PUT&#34;,
            url=res.get(&#34;uploadUrl&#34;),
            api_path=None,
            upload_file=source,
            headers={
                &#34;Content-Length&#34;: str(file_size),
                &#34;Authorization&#34;: None,
                &#34;LifeOmic-Account&#34;: None,
                &#34;Content-Type&#34;: None,
            },
        )
        return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Genomics"><code class="flex name class">
<span>class <span class="ident">Genomics</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC genomic resources</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Genomics(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC genomic resources

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    class SetType(Enum):
        VARIANT = &#34;variantsets&#34;
        STRUCTURAL_VARIANT = &#34;fusionsets&#34;
        RNA = &#34;rnaquantificationsets&#34;
        READ = &#34;readgroupsets&#34;
        COPY_NUMBER = &#34;copynumbersets&#34;

    class Reference(Enum):
        GRCh37 = &#34;GRCh37&#34;
        GRCh38 = &#34;GRCh38&#34;

    class SequenceType(Enum):
        GERMLINE = &#34;germline&#34;
        SOMATIC = &#34;somatic&#34;
        METASTATIC = &#34;metastatic&#34;
        CTDNA = &#34;ctDNA&#34;
        RNA = &#34;rna&#34;

    class Status(Enum):
        ACTIVE = &#34;ACTIVE&#34;
        INDEXING = &#34;INDEXING&#34;
        FAILED = &#34;FAILED&#34;

    def create_set(
        self,
        set_type: SetType,
        project_id: str,
        name: str,
        file_id: str,
        patient_id: str,
        reference: Reference,
        sequence_type: SequenceType,
        test_type: str,
        sequence_id: str = str(uuid.uuid4()),
        indexed_date: datetime = None,
        performer_id: str = None,
        test_id: str = None,
        update_sample: bool = False,
        pass_filter: bool = False,
        output_vcf_name: str = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a genomic set

        Parameters
        ----------
        set_type : SetType
            The genomic set type
        project_id : str
            The project ID
        name : str
            The set name
        file_id : str
            The genomic file ID
        patient_id : str
            The patient ID
        reference : Reference
            The genomic reference
        sequence_type : SequenceType
            The sequence type
        test_type : str
            The test type
        sequence_id : str, optional
            The FHIR Sequence ID, by default str(uuid.uuid4())
        indexed_date : datetime, optional
            The indexed date, by default None
        performer_id : str, optional
            The performer ID, by default None
        test_id : str, optional
            The test ID, by default None
        update_sample : bool, optional
            For variants only, True to update the sample ID, by default False
        pass_filter : bool, optional
            For variants only, True to update all filters to pass, by default False
        output_vcf_name : str, optional
            For variants only, the name of the output VCF, by default None

        Returns
        -------
        ApiResponse
            The create set response
        &#34;&#34;&#34;
        json_body = {
            &#34;datasetId&#34;: project_id,
            &#34;name&#34;: name,
            &#34;patientId&#34;: patient_id,
            &#34;referenceSetId&#34;: reference.value,
            &#34;sequenceType&#34;: sequence_type.value,
            &#34;testType&#34;: test_type,
            &#34;indexedDate&#34;: indexed_date.isoformat() if indexed_date else None,
            &#34;performerId&#34;: performer_id,
            &#34;testId&#34;: test_id,
            &#34;sequenceId&#34;: sequence_id,
        }

        if set_type == Genomics.SetType.VARIANT:
            json_body[&#34;variantsFileIds&#34;] = [file_id]
            json_body[&#34;updateSample&#34;] = (update_sample,)
            json_body[&#34;passFile&#34;] = pass_filter
            json_body[&#34;outputVcfName&#34;] = output_vcf_name

            return self._ga4gh_call(
                &#34;genomicsets&#34;, json=json_body, http_verb=&#34;POST&#34;
            )
        else:
            json_body[&#34;fileId&#34;] = file_id

            return self._ga4gh_call(
                set_type.value, json=json_body, http_verb=&#34;POST&#34;
            )

    def update_set(
        self, set_type: SetType, set_id: str, updates: dict
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Update a genomic set

        Parameters
        ----------
        set_type : SetType
            The set type
        set_id : str
            The set ID
        updates : dict
            The updates to apply

        Returns
        -------
        ApiResponse
            The fetch response
        &#34;&#34;&#34;
        return self._ga4gh_call(
            f&#34;{set_type.value}/{set_id}&#34;, json=updates, http_verb=&#34;PATCH&#34;
        )

    def get_set(self, set_type: SetType, set_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a genomic set

        Parameters
        ----------
        set_type : SetType
            The set type
        set_id : str
            The set ID

        Returns
        -------
        ApiResponse
            The fetch response
        &#34;&#34;&#34;
        return self._ga4gh_call(f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;GET&#34;)

    def delete_set(self, set_type: SetType, set_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a genomic set

        Parameters
        ----------
        set_type : SetType
            The set type
        set_id : str
            The set ID

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._ga4gh_call(
                f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 204
        )

    def list_sets(
        self,
        set_type: SetType,
        project_id: str,
        sequence_id: str = None,
        patient_id: str = None,
        status: Status = None,
        next_page_token: str = None,
        page_size: int = 50,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;List genomic sets

        Parameters
        ----------
        set_type : SetType
            The set type
        project_id : str
            The project ID
        sequence_id : str, optional
            List sets by sequence ID, by default None
        patient_id : str, optional
            List sets by patient ID, by default None
        status : Status, optional
            Filter sets by status, by default None
        next_page_token : str, optional
            The next page token, by default None
        page_size : int, optional
            The page size, by default 50

        Returns
        -------
        ApiResponse
            The list sets response
        &#34;&#34;&#34;

        json_body = {
            &#34;datasetIds&#34;: [project_id],
            &#34;status&#34;: status,
            &#34;patientId&#34;: patient_id,
            &#34;sequenceId&#34;: sequence_id,
            &#34;pageSize&#34;: page_size,
            &#34;pageToken&#34;: next_page_token,
        }

        return self._ga4gh_call(
            f&#34;{set_type.value}/search&#34;, json=json_body, http_verb=&#34;POST&#34;
        )

    def list_tests(self, project_id: str, patient_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;List tests for a patient

        Parameters
        ----------
        project_id : str
            The project ID
        patient_id : str
            The patient ID

        Returns
        -------
        ApiResponse
            The list tests response
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;genomics/projects/{project_id}/subjects/{patient_id}/tests&#34;,
            http_verb=&#34;GET&#34;,
        )

    def get_test(self, project_id: str, test_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Get test by project and test id

        Parameters
        ----------
        project_id : str
            The project ID
        test_id : str
            The Test ID

        Returns
        -------
        ApiResponse
            The get test response
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;, http_verb=&#34;GET&#34;
        )

    def delete_test(self, project_id: str, test_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a genomic test

        Parameters
        ----------
        project_id : SetType
            The project ID
        test_id : str
            The test ID

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._ga4gh_call(
                f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;,
                http_verb=&#34;DELETE&#34;,
            ).status_code
            == 204
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="phc.services.Genomics.Reference"><code class="name">var <span class="ident">Reference</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="phc.services.Genomics.SequenceType"><code class="name">var <span class="ident">SequenceType</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="phc.services.Genomics.SetType"><code class="name">var <span class="ident">SetType</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="phc.services.Genomics.Status"><code class="name">var <span class="ident">Status</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Genomics.create_set"><code class="name flex">
<span>def <span class="ident">create_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, project_id: str, name: str, file_id: str, patient_id: str, reference: phc.services.genomics.Genomics.Reference, sequence_type: phc.services.genomics.Genomics.SequenceType, test_type: str, sequence_id: str = '5a603d49-11c4-413a-8a94-d9231ff4395a', indexed_date: datetime.datetime = None, performer_id: str = None, test_id: str = None, update_sample: bool = False, pass_filter: bool = False, output_vcf_name: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The genomic set type</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The set name</dd>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The genomic file ID</dd>
<dt><strong><code>patient_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The patient ID</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>Reference</code></dt>
<dd>The genomic reference</dd>
<dt><strong><code>sequence_type</code></strong> :&ensp;<code>SequenceType</code></dt>
<dd>The sequence type</dd>
<dt><strong><code>test_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The test type</dd>
<dt><strong><code>sequence_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The FHIR Sequence ID, by default str(uuid.uuid4())</dd>
<dt><strong><code>indexed_date</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The indexed date, by default None</dd>
<dt><strong><code>performer_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The performer ID, by default None</dd>
<dt><strong><code>test_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The test ID, by default None</dd>
<dt><strong><code>update_sample</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>For variants only, True to update the sample ID, by default False</dd>
<dt><strong><code>pass_filter</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>For variants only, True to update all filters to pass, by default False</dd>
<dt><strong><code>output_vcf_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>For variants only, the name of the output VCF, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The create set response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_set(
    self,
    set_type: SetType,
    project_id: str,
    name: str,
    file_id: str,
    patient_id: str,
    reference: Reference,
    sequence_type: SequenceType,
    test_type: str,
    sequence_id: str = str(uuid.uuid4()),
    indexed_date: datetime = None,
    performer_id: str = None,
    test_id: str = None,
    update_sample: bool = False,
    pass_filter: bool = False,
    output_vcf_name: str = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a genomic set

    Parameters
    ----------
    set_type : SetType
        The genomic set type
    project_id : str
        The project ID
    name : str
        The set name
    file_id : str
        The genomic file ID
    patient_id : str
        The patient ID
    reference : Reference
        The genomic reference
    sequence_type : SequenceType
        The sequence type
    test_type : str
        The test type
    sequence_id : str, optional
        The FHIR Sequence ID, by default str(uuid.uuid4())
    indexed_date : datetime, optional
        The indexed date, by default None
    performer_id : str, optional
        The performer ID, by default None
    test_id : str, optional
        The test ID, by default None
    update_sample : bool, optional
        For variants only, True to update the sample ID, by default False
    pass_filter : bool, optional
        For variants only, True to update all filters to pass, by default False
    output_vcf_name : str, optional
        For variants only, the name of the output VCF, by default None

    Returns
    -------
    ApiResponse
        The create set response
    &#34;&#34;&#34;
    json_body = {
        &#34;datasetId&#34;: project_id,
        &#34;name&#34;: name,
        &#34;patientId&#34;: patient_id,
        &#34;referenceSetId&#34;: reference.value,
        &#34;sequenceType&#34;: sequence_type.value,
        &#34;testType&#34;: test_type,
        &#34;indexedDate&#34;: indexed_date.isoformat() if indexed_date else None,
        &#34;performerId&#34;: performer_id,
        &#34;testId&#34;: test_id,
        &#34;sequenceId&#34;: sequence_id,
    }

    if set_type == Genomics.SetType.VARIANT:
        json_body[&#34;variantsFileIds&#34;] = [file_id]
        json_body[&#34;updateSample&#34;] = (update_sample,)
        json_body[&#34;passFile&#34;] = pass_filter
        json_body[&#34;outputVcfName&#34;] = output_vcf_name

        return self._ga4gh_call(
            &#34;genomicsets&#34;, json=json_body, http_verb=&#34;POST&#34;
        )
    else:
        json_body[&#34;fileId&#34;] = file_id

        return self._ga4gh_call(
            set_type.value, json=json_body, http_verb=&#34;POST&#34;
        )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.delete_set"><code class="name flex">
<span>def <span class="ident">delete_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, set_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>set_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The set ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_set(self, set_type: SetType, set_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a genomic set

    Parameters
    ----------
    set_type : SetType
        The set type
    set_id : str
        The set ID

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._ga4gh_call(
            f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.delete_test"><code class="name flex">
<span>def <span class="ident">delete_test</span></span>(<span>self, project_id: str, test_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a genomic test</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The project ID</dd>
<dt><strong><code>test_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The test ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_test(self, project_id: str, test_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a genomic test

    Parameters
    ----------
    project_id : SetType
        The project ID
    test_id : str
        The test ID

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._ga4gh_call(
            f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;,
            http_verb=&#34;DELETE&#34;,
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.get_set"><code class="name flex">
<span>def <span class="ident">get_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, set_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>set_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The set ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The fetch response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_set(self, set_type: SetType, set_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a genomic set

    Parameters
    ----------
    set_type : SetType
        The set type
    set_id : str
        The set ID

    Returns
    -------
    ApiResponse
        The fetch response
    &#34;&#34;&#34;
    return self._ga4gh_call(f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.get_test"><code class="name flex">
<span>def <span class="ident">get_test</span></span>(<span>self, project_id: str, test_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Get test by project and test id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>test_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Test ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The get test response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_test(self, project_id: str, test_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Get test by project and test id

    Parameters
    ----------
    project_id : str
        The project ID
    test_id : str
        The Test ID

    Returns
    -------
    ApiResponse
        The get test response
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.list_sets"><code class="name flex">
<span>def <span class="ident">list_sets</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, project_id: str, sequence_id: str = None, patient_id: str = None, status: phc.services.genomics.Genomics.Status = None, next_page_token: str = None, page_size: int = 50) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>List genomic sets</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>sequence_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>List sets by sequence ID, by default None</dd>
<dt><strong><code>patient_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>List sets by patient ID, by default None</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>Status</code>, optional</dt>
<dd>Filter sets by status, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default 50</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The list sets response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_sets(
    self,
    set_type: SetType,
    project_id: str,
    sequence_id: str = None,
    patient_id: str = None,
    status: Status = None,
    next_page_token: str = None,
    page_size: int = 50,
) -&gt; ApiResponse:
    &#34;&#34;&#34;List genomic sets

    Parameters
    ----------
    set_type : SetType
        The set type
    project_id : str
        The project ID
    sequence_id : str, optional
        List sets by sequence ID, by default None
    patient_id : str, optional
        List sets by patient ID, by default None
    status : Status, optional
        Filter sets by status, by default None
    next_page_token : str, optional
        The next page token, by default None
    page_size : int, optional
        The page size, by default 50

    Returns
    -------
    ApiResponse
        The list sets response
    &#34;&#34;&#34;

    json_body = {
        &#34;datasetIds&#34;: [project_id],
        &#34;status&#34;: status,
        &#34;patientId&#34;: patient_id,
        &#34;sequenceId&#34;: sequence_id,
        &#34;pageSize&#34;: page_size,
        &#34;pageToken&#34;: next_page_token,
    }

    return self._ga4gh_call(
        f&#34;{set_type.value}/search&#34;, json=json_body, http_verb=&#34;POST&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.list_tests"><code class="name flex">
<span>def <span class="ident">list_tests</span></span>(<span>self, project_id: str, patient_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>List tests for a patient</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>patient_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The patient ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The list tests response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_tests(self, project_id: str, patient_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;List tests for a patient

    Parameters
    ----------
    project_id : str
        The project ID
    patient_id : str
        The patient ID

    Returns
    -------
    ApiResponse
        The list tests response
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;genomics/projects/{project_id}/subjects/{patient_id}/tests&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.update_set"><code class="name flex">
<span>def <span class="ident">update_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, set_id: str, updates: dict) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Update a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>set_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The set ID</dd>
<dt><strong><code>updates</code></strong> :&ensp;<code>dict</code></dt>
<dd>The updates to apply</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The fetch response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_set(
    self, set_type: SetType, set_id: str, updates: dict
) -&gt; ApiResponse:
    &#34;&#34;&#34;Update a genomic set

    Parameters
    ----------
    set_type : SetType
        The set type
    set_id : str
        The set ID
    updates : dict
        The updates to apply

    Returns
    -------
    ApiResponse
        The fetch response
    &#34;&#34;&#34;
    return self._ga4gh_call(
        f&#34;{set_type.value}/{set_id}&#34;, json=updates, http_verb=&#34;PATCH&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Projects"><code class="flex name class">
<span>class <span class="ident">Projects</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC projects</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Projects(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC projects

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def create(self, name: str, description: str = None) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a project

        Parameters
        ----------
        name : str
            The project name.
        description : str, optional
            The project description, by default None

        Returns
        -------
        phc.ApiResponse
            The create project response
        &#34;&#34;&#34;
        json_body = {&#34;name&#34;: name}
        if description:
            json_body[&#34;description&#34;] = description
        return self._api_call(&#34;projects&#34;, json=json_body, http_verb=&#34;POST&#34;)

    def get(self, project_id) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a project by id

        Parameters
        ----------
        project_id : str
            The project ID.

        Returns
        -------
        phc.ApiResponse
            The get project response
        &#34;&#34;&#34;
        return self._api_call(f&#34;projects/{project_id}&#34;, http_verb=&#34;GET&#34;)

    def update(
        self, project_id: str, name: str, description: str = None
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Update a project

        Parameters
        ----------
         project_id : str
            The project ID.
        name : str
            The project name.
        description : str, optional
            The project description, by default None

        Returns
        -------
        phc.ApiResponse
            The update project response
        &#34;&#34;&#34;
        json_body = {&#34;name&#34;: name}
        if description:
            json_body[&#34;description&#34;] = description
        return self._api_call(
            f&#34;projects/{project_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
        ).data

    def delete(self, project_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a project

        Parameters
        ----------
        project_id : str
            The project ID.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._api_call(
                f&#34;projects/{project_id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 204
        )

    def get_list(
        self,
        page_size: int = None,
        next_page_token: str = None,
        name: str = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of projects in an account

        Parameters
        ----------
        page_size : int, optional
            The page size, by default None
        next_page_token : str, optional
            The next page token, by default None
        name : str, optional
            A project name filter, by default None

        Returns
        -------
        phc.ApiResponse
            The list projects response
        &#34;&#34;&#34;
        query_dict = {}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if name:
            query_dict[&#34;name&#34;] = name
        return self._api_call(
            f&#34;projects?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Projects.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, name: str, description: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The project name.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The project description, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The create project response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, name: str, description: str = None) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a project

    Parameters
    ----------
    name : str
        The project name.
    description : str, optional
        The project description, by default None

    Returns
    -------
    phc.ApiResponse
        The create project response
    &#34;&#34;&#34;
    json_body = {&#34;name&#34;: name}
    if description:
        json_body[&#34;description&#34;] = description
    return self._api_call(&#34;projects&#34;, json=json_body, http_verb=&#34;POST&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, project_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, project_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a project

    Parameters
    ----------
    project_id : str
        The project ID.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._api_call(
            f&#34;projects/{project_id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, project_id) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a project by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get project response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, project_id) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a project by id

    Parameters
    ----------
    project_id : str
        The project ID.

    Returns
    -------
    phc.ApiResponse
        The get project response
    &#34;&#34;&#34;
    return self._api_call(f&#34;projects/{project_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, page_size: int = None, next_page_token: str = None, name: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of projects in an account</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A project name filter, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list projects response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    page_size: int = None,
    next_page_token: str = None,
    name: str = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of projects in an account

    Parameters
    ----------
    page_size : int, optional
        The page size, by default None
    next_page_token : str, optional
        The next page token, by default None
    name : str, optional
        A project name filter, by default None

    Returns
    -------
    phc.ApiResponse
        The list projects response
    &#34;&#34;&#34;
    query_dict = {}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if name:
        query_dict[&#34;name&#34;] = name
    return self._api_call(
        f&#34;projects?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, project_id: str, name: str, description: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Update a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>project_id : str</dt>
<dt>The project ID.</dt>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The project name.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The project description, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The update project response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(
    self, project_id: str, name: str, description: str = None
) -&gt; ApiResponse:
    &#34;&#34;&#34;Update a project

    Parameters
    ----------
     project_id : str
        The project ID.
    name : str
        The project name.
    description : str, optional
        The project description, by default None

    Returns
    -------
    phc.ApiResponse
        The update project response
    &#34;&#34;&#34;
    json_body = {&#34;name&#34;: name}
    if description:
        json_body[&#34;description&#34;] = description
    return self._api_call(
        f&#34;projects/{project_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
    ).data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Tools"><code class="flex name class">
<span>class <span class="ident">Tools</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC tools registry</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tools(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC tools registry

    Parameters
    ----------
    session: phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def create(
        self,
        name: str,
        description: str,
        access: ToolAccess,
        version: str,
        tool_class: ToolClass,
        source: str,
        labels: Optional[List[str]] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a tool.

        Parameters
        ----------
        name: str
            The name to give to the tool
        description: str
            A description of the tool
        access: ToolAccess
            The access level given to the tool [PRIVATE, ACCOUNT, PHC, PUBLIC]
        version: str
            The initial version of the tool
        tool_class: ToolClass
            The class of the tool [Workflow, Notebook]
        source: str
            The path of the tool to upload
        labels: List[str], optional
            A list of labels to apply to the tool, i.e. [&#34;bam&#34;,&#34;samtools&#34;]

        Returns
        -------
        ApiResponse
            The create tool response

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Tools
        &gt;&gt;&gt; tools = Tools(session)
        &gt;&gt;&gt; tools.create(name=&#34;Read Depth Notebook&#34;, description=&#34;Generates a chart of positional read depth from a bam file&#34;,
              access=&#34;PHC&#34;, version=&#34;1.0.0&#34;, tool_class=&#34;Notebook&#34;, source=&#34;./mynotebook.ipynb&#34;, labels=[&#34;bam&#34;,&#34;samtools]&#34;)
        &#34;&#34;&#34;
        if not hasattr(ToolClass, tool_class):
            raise ValueError(
                f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
            )

        if not hasattr(ToolAccess, access):
            raise ValueError(
                f&#34;{access} is not a valid Tool Class value {[e.value for e in ToolAccess]}&#34;
            )

        create_request = {
            &#34;version&#34;: version,
            &#34;access&#34;: access,
            &#34;name&#34;: name,
            &#34;toolClassId&#34;: ToolClassIdMappings[tool_class],
            &#34;descriptorType&#34;: DescriptorTypeMappings[tool_class],
            &#34;description&#34;: description,
        }
        if labels:
            create_request[&#34;labels&#34;] = labels

        res = self._api_call(
            &#34;/v1/trs/v2/tools&#34;, json=create_request, http_verb=&#34;POST&#34;
        )

        upload_request = {
            &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
            &#34;toolId&#34;: res[&#34;id&#34;],
            &#34;version&#34;: res[&#34;meta_version&#34;],
        }

        upload_response = self._api_call(
            &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
        )
        file_size = os.path.getsize(source)
        self._api_call_impl(
            http_verb=&#34;PUT&#34;,
            url=upload_response[&#34;uploadUrl&#34;],
            api_path=None,
            upload_file=source,
            headers={
                &#34;Content-Length&#34;: str(file_size),
                &#34;Authorization&#34;: None,
                &#34;LifeOmic-Account&#34;: None,
                &#34;Content-Type&#34;: None,
            },
        )
        return res

    @backoff.on_exception(
        backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
    )
    def download(
        self,
        tool_id: str,
        version: Optional[str] = None,
        dest_dir: Optional[str] = os.getcwd(),
    ) -&gt; None:
        &#34;&#34;&#34;Download a tool

        Parameters
        ----------
        tool_id : str
            The tool ID
        version : str, optional
            The version.
        dest_dir : str, optional
            The local directory to save the tool.  Defaults to the current working directory

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Tools
        &gt;&gt;&gt; tools = Tools(session)
        &gt;&gt;&gt; tools.download(tool_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
        &#34;&#34;&#34;
        id = f&#34;{tool_id}:{version}&#34; if version else tool_id
        res = self._api_call(f&#34;/v1/trs/files/{id}/download&#34;, http_verb=&#34;GET&#34;)

        file_path = os.path.join(dest_dir, res.get(&#34;fileName&#34;))
        target_dir = os.path.dirname(file_path)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
        return file_path

    def get(self, tool_id: str, version: Optional[str] = None) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a tool by id

        Parameters
        ----------
        tool_id : str
            The tool ID.
        version : str, optional
            The version.

        Returns
        -------
        phc.ApiResponse
            The get tool response
        &#34;&#34;&#34;
        id = f&#34;{tool_id}:{version}&#34; if version else tool_id
        return self._api_call(f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;GET&#34;)

    def add_version(
        self,
        tool_id: str,
        version: str,
        source: str,
        is_default: Optional[bool] = False,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Adds a new version to a tool.

        Parameters
        ----------
        tool_id : str
            The tool ID to add the version to.
        version : str
            The new version for the tool.
        source: str
            The path of the version to upload.
        is_default: bool = False
            Updates default setting for the tool.

        Returns
        -------
        phc.ApiResponse
            The updated tool response
        &#34;&#34;&#34;
        version_request = {&#34;version&#34;: version, &#34;isDefault&#34;: is_default}

        res = self._api_call(
            f&#34;/v1/trs/v2/tools/{tool_id}/versions&#34;,
            json=version_request,
            http_verb=&#34;POST&#34;,
        )
        upload_request = {
            &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
            &#34;toolId&#34;: res[&#34;id&#34;],
            &#34;version&#34;: res[&#34;meta_version&#34;],
        }

        upload_response = self._api_call(
            &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
        )
        file_size = os.path.getsize(source)
        self._api_call_impl(
            http_verb=&#34;PUT&#34;,
            url=upload_response[&#34;uploadUrl&#34;],
            api_path=None,
            upload_file=source,
            headers={
                &#34;Content-Length&#34;: str(file_size),
                &#34;Authorization&#34;: None,
                &#34;LifeOmic-Account&#34;: None,
                &#34;Content-Type&#34;: None,
            },
        )
        return res

    def delete(self, tool_id: str, version: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;Deletes a tool

        Parameters
        ----------
        tool_id : str
            The tool ID.
        version : str, optional
            The version.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        id = f&#34;{tool_id}:{version}&#34; if version else tool_id
        return (
            self._api_call(
                f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 200
        )

    def get_list(
        self,
        tool_class: Optional[ToolClass] = None,
        organization: Optional[str] = None,
        tool_name: Optional[str] = None,
        author: Optional[str] = None,
        labels: Optional[List[str]] = None,
        page_size: Optional[int] = 1000,
        page_count: Optional[int] = 0,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of tools from the registry

        Parameters
        ----------
        tool_class: str, optional
            The class of the tool, by default None
        organization: str, optional
            The organization that owns the tool, by default None
        tool_name: str, optional
            The name of the tool, by default None
        author: str, optional
            The creator of the tool, by default None
        labels: List[str], optional
            A list of labels describing the tool, by default None
        page_size: int, optional
            The count of tools to return in a single request, by default 1000
        page_count: int, optional
            The page count to return, by default 0

        Returns
        -------
        phc.ApiResponse
            The list files response
        &#34;&#34;&#34;
        query_dict = {&#34;limit&#34;: page_size, &#34;offset&#34;: page_count}
        if tool_class:
            if not hasattr(ToolClass, tool_class):
                raise ValueError(
                    f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
                )
            query_dict[&#34;toolClass&#34;] = tool_class
        if organization:
            query_dict[&#34;organization&#34;] = organization
        if tool_name:
            query_dict[&#34;toolname&#34;] = tool_name
        if author:
            query_dict[&#34;author&#34;] = author
        if labels:
            query_dict[&#34;label&#34;] = &#34;,&#34;.join(labels)

        return self._api_call(
            f&#34;/v1/trs/v2/tools?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Tools.add_version"><code class="name flex">
<span>def <span class="ident">add_version</span></span>(<span>self, tool_id: str, version: str, source: str, is_default: Optional[bool] = False) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new version to a tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID to add the version to.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>The new version for the tool.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the version to upload.</dd>
<dt><strong><code>is_default</code></strong> :&ensp;<code>bool = False</code></dt>
<dd>Updates default setting for the tool.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The updated tool response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_version(
    self,
    tool_id: str,
    version: str,
    source: str,
    is_default: Optional[bool] = False,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Adds a new version to a tool.

    Parameters
    ----------
    tool_id : str
        The tool ID to add the version to.
    version : str
        The new version for the tool.
    source: str
        The path of the version to upload.
    is_default: bool = False
        Updates default setting for the tool.

    Returns
    -------
    phc.ApiResponse
        The updated tool response
    &#34;&#34;&#34;
    version_request = {&#34;version&#34;: version, &#34;isDefault&#34;: is_default}

    res = self._api_call(
        f&#34;/v1/trs/v2/tools/{tool_id}/versions&#34;,
        json=version_request,
        http_verb=&#34;POST&#34;,
    )
    upload_request = {
        &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
        &#34;toolId&#34;: res[&#34;id&#34;],
        &#34;version&#34;: res[&#34;meta_version&#34;],
    }

    upload_response = self._api_call(
        &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
    )
    file_size = os.path.getsize(source)
    self._api_call_impl(
        http_verb=&#34;PUT&#34;,
        url=upload_response[&#34;uploadUrl&#34;],
        api_path=None,
        upload_file=source,
        headers={
            &#34;Content-Length&#34;: str(file_size),
            &#34;Authorization&#34;: None,
            &#34;LifeOmic-Account&#34;: None,
            &#34;Content-Type&#34;: None,
        },
    )
    return res</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, name: str, description: str, access: phc.services.tools.ToolAccess, version: str, tool_class: phc.services.tools.ToolClass, source: str, labels: Optional[List[str]] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name to give to the tool</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of the tool</dd>
<dt><strong><code>access</code></strong> :&ensp;<code>ToolAccess</code></dt>
<dd>The access level given to the tool [PRIVATE, ACCOUNT, PHC, PUBLIC]</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>The initial version of the tool</dd>
<dt><strong><code>tool_class</code></strong> :&ensp;<code>ToolClass</code></dt>
<dd>The class of the tool [Workflow, Notebook]</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the tool to upload</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>A list of labels to apply to the tool, i.e. ["bam","samtools"]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The create tool response</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Tools
&gt;&gt;&gt; tools = Tools(session)
&gt;&gt;&gt; tools.create(name=&quot;Read Depth Notebook&quot;, description=&quot;Generates a chart of positional read depth from a bam file&quot;,
      access=&quot;PHC&quot;, version=&quot;1.0.0&quot;, tool_class=&quot;Notebook&quot;, source=&quot;./mynotebook.ipynb&quot;, labels=[&quot;bam&quot;,&quot;samtools]&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(
    self,
    name: str,
    description: str,
    access: ToolAccess,
    version: str,
    tool_class: ToolClass,
    source: str,
    labels: Optional[List[str]] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a tool.

    Parameters
    ----------
    name: str
        The name to give to the tool
    description: str
        A description of the tool
    access: ToolAccess
        The access level given to the tool [PRIVATE, ACCOUNT, PHC, PUBLIC]
    version: str
        The initial version of the tool
    tool_class: ToolClass
        The class of the tool [Workflow, Notebook]
    source: str
        The path of the tool to upload
    labels: List[str], optional
        A list of labels to apply to the tool, i.e. [&#34;bam&#34;,&#34;samtools&#34;]

    Returns
    -------
    ApiResponse
        The create tool response

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Tools
    &gt;&gt;&gt; tools = Tools(session)
    &gt;&gt;&gt; tools.create(name=&#34;Read Depth Notebook&#34;, description=&#34;Generates a chart of positional read depth from a bam file&#34;,
          access=&#34;PHC&#34;, version=&#34;1.0.0&#34;, tool_class=&#34;Notebook&#34;, source=&#34;./mynotebook.ipynb&#34;, labels=[&#34;bam&#34;,&#34;samtools]&#34;)
    &#34;&#34;&#34;
    if not hasattr(ToolClass, tool_class):
        raise ValueError(
            f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
        )

    if not hasattr(ToolAccess, access):
        raise ValueError(
            f&#34;{access} is not a valid Tool Class value {[e.value for e in ToolAccess]}&#34;
        )

    create_request = {
        &#34;version&#34;: version,
        &#34;access&#34;: access,
        &#34;name&#34;: name,
        &#34;toolClassId&#34;: ToolClassIdMappings[tool_class],
        &#34;descriptorType&#34;: DescriptorTypeMappings[tool_class],
        &#34;description&#34;: description,
    }
    if labels:
        create_request[&#34;labels&#34;] = labels

    res = self._api_call(
        &#34;/v1/trs/v2/tools&#34;, json=create_request, http_verb=&#34;POST&#34;
    )

    upload_request = {
        &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
        &#34;toolId&#34;: res[&#34;id&#34;],
        &#34;version&#34;: res[&#34;meta_version&#34;],
    }

    upload_response = self._api_call(
        &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
    )
    file_size = os.path.getsize(source)
    self._api_call_impl(
        http_verb=&#34;PUT&#34;,
        url=upload_response[&#34;uploadUrl&#34;],
        api_path=None,
        upload_file=source,
        headers={
            &#34;Content-Length&#34;: str(file_size),
            &#34;Authorization&#34;: None,
            &#34;LifeOmic-Account&#34;: None,
            &#34;Content-Type&#34;: None,
        },
    )
    return res</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, tool_id: str, version: Optional[str] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a tool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, tool_id: str, version: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;Deletes a tool

    Parameters
    ----------
    tool_id : str
        The tool ID.
    version : str, optional
        The version.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    id = f&#34;{tool_id}:{version}&#34; if version else tool_id
    return (
        self._api_call(
            f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 200
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, tool_id: str, version: Optional[str] = None, dest_dir: Optional[str] = '/home/runner/work/phc-sdk-py/phc-sdk-py') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download a tool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The version.</dd>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The local directory to save the tool.
Defaults to the current working directory</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Tools
&gt;&gt;&gt; tools = Tools(session)
&gt;&gt;&gt; tools.download(tool_id=&quot;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&quot;, dest_dir=&quot;./mydata&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@backoff.on_exception(
    backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
)
def download(
    self,
    tool_id: str,
    version: Optional[str] = None,
    dest_dir: Optional[str] = os.getcwd(),
) -&gt; None:
    &#34;&#34;&#34;Download a tool

    Parameters
    ----------
    tool_id : str
        The tool ID
    version : str, optional
        The version.
    dest_dir : str, optional
        The local directory to save the tool.  Defaults to the current working directory

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Tools
    &gt;&gt;&gt; tools = Tools(session)
    &gt;&gt;&gt; tools.download(tool_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
    &#34;&#34;&#34;
    id = f&#34;{tool_id}:{version}&#34; if version else tool_id
    res = self._api_call(f&#34;/v1/trs/files/{id}/download&#34;, http_verb=&#34;GET&#34;)

    file_path = os.path.join(dest_dir, res.get(&#34;fileName&#34;))
    target_dir = os.path.dirname(file_path)
    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
    return file_path</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, tool_id: str, version: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a tool by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get tool response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, tool_id: str, version: Optional[str] = None) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a tool by id

    Parameters
    ----------
    tool_id : str
        The tool ID.
    version : str, optional
        The version.

    Returns
    -------
    phc.ApiResponse
        The get tool response
    &#34;&#34;&#34;
    id = f&#34;{tool_id}:{version}&#34; if version else tool_id
    return self._api_call(f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, tool_class: Optional[phc.services.tools.ToolClass] = None, organization: Optional[str] = None, tool_name: Optional[str] = None, author: Optional[str] = None, labels: Optional[List[str]] = None, page_size: Optional[int] = 1000, page_count: Optional[int] = 0) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of tools from the registry</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_class</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The class of the tool, by default None</dd>
<dt><strong><code>organization</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The organization that owns the tool, by default None</dd>
<dt><strong><code>tool_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the tool, by default None</dd>
<dt><strong><code>author</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The creator of the tool, by default None</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>A list of labels describing the tool, by default None</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The count of tools to return in a single request, by default 1000</dd>
<dt><strong><code>page_count</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page count to return, by default 0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list files response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    tool_class: Optional[ToolClass] = None,
    organization: Optional[str] = None,
    tool_name: Optional[str] = None,
    author: Optional[str] = None,
    labels: Optional[List[str]] = None,
    page_size: Optional[int] = 1000,
    page_count: Optional[int] = 0,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of tools from the registry

    Parameters
    ----------
    tool_class: str, optional
        The class of the tool, by default None
    organization: str, optional
        The organization that owns the tool, by default None
    tool_name: str, optional
        The name of the tool, by default None
    author: str, optional
        The creator of the tool, by default None
    labels: List[str], optional
        A list of labels describing the tool, by default None
    page_size: int, optional
        The count of tools to return in a single request, by default 1000
    page_count: int, optional
        The page count to return, by default 0

    Returns
    -------
    phc.ApiResponse
        The list files response
    &#34;&#34;&#34;
    query_dict = {&#34;limit&#34;: page_size, &#34;offset&#34;: page_count}
    if tool_class:
        if not hasattr(ToolClass, tool_class):
            raise ValueError(
                f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
            )
        query_dict[&#34;toolClass&#34;] = tool_class
    if organization:
        query_dict[&#34;organization&#34;] = organization
    if tool_name:
        query_dict[&#34;toolname&#34;] = tool_name
    if author:
        query_dict[&#34;author&#34;] = author
    if labels:
        query_dict[&#34;label&#34;] = &#34;,&#34;.join(labels)

    return self._api_call(
        f&#34;/v1/trs/v2/tools?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Workflows"><code class="flex name class">
<span>class <span class="ident">Workflows</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC Workflows</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Workflows(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC Workflows

    Parameters
    ----------
    session: phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def run(
        self,
        project_id: str,
        name: str,
        tool: str,
        workflow_inputs: Optional[str] = None,
        workflow_inputs_file_id: Optional[str] = None,
        output_project_folder: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a tool.

        Parameters
        ----------
        project_id: str
            The project ID
        name: str
            The name to give to this run of a tool
        tool: str
            The tool id or organization/name of the tool to run
        workflow_inputs: str, optional
            The inputs required by the workflow as a json string, either this or workflow_inputs_file_id are required
        workflow_inputs_file_id: str, optional
            The inputs required by the workflow as provided in a file in PHC, either this or workflow_inputs are required
        output_project_folder: str, optional
            The destination output folder in PHC for the workflow run outputs

        Returns
        -------
        ApiResponse
            The workflow run response

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Workflows
        &gt;&gt;&gt; workflows = Workflows(session)
        &gt;&gt;&gt; workflows.run(project_id=&#34;d2876f48-724f-4987-9cf0-92c7ef99a9fa&#34;,
              name=&#34;Ashion ingest subj: 2405&#34;,
              tool=&#34;lifeomic/ashion-ingest-workflow&#34;,
              workflow_inputs=&#34;{&#39;reference&#39;: &#39;GRCh37&#39;,&#39;tarFile&#39;: {&#39;class&#39;: &#39;File&#39;,&#39;fileId&#39;: &#39;28235c74-9731-4496-bb3c-41c361f106f3&#39;}, &#39;source&#39;: &#39;incoming/ashion_C043_9999_009990_T1_K1ID2_ps20190814000000.tar.gz&#39;}&#34;)
        &#34;&#34;&#34;
        create_request = {
            &#34;datasetId&#34;: project_id,
            &#34;name&#34;: name,
            &#34;workflowSourceFileId&#34;: tool,
        }

        if workflow_inputs:
            create_request[&#34;workflowInputs&#34;] = workflow_inputs
        elif workflow_inputs_file_id:
            create_request[&#34;workflowInputsFileId&#34;] = workflow_inputs_file_id
        else:
            raise ValueError(
                &#34;Must provide a value for the workflow_inputs or workflow_inputs_file_id&#34;
            )

        if output_project_folder:
            create_request[&#34;outputProjectFolder&#34;] = output_project_folder

        res = self._api_call(
            &#34;/v1/workflows/ga4gh/wes/runs&#34;,
            json=create_request,
            http_verb=&#34;POST&#34;,
        )
        return res

    def get(self, project_id: str, workflow_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Get workflow metadata by id

        Parameters
        ----------
        project_id: str
            The project ID
        workflow_id : str
            The workflow ID.

        Returns
        -------
        phc.ApiResponse
            The get workflow response
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;/v1/workflows/ga4gh/wes/runs/{project_id}:{workflow_id}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def get_list(
        self,
        project_id: str,
        page_size: Optional[int] = 100,
        next_page_token: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of workflows run in the specified project

        Parameters
        ----------
        project_id: str
            The project ID
        page_size : int, optional
            The page size, by default 100
        next_page_token : str, optional
            The next page token, by default None

        Returns
        -------
        phc.ApiResponse
            The list workflow run response
        &#34;&#34;&#34;
        query_dict = {&#34;datasetId&#34;: project_id}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token

        return self._api_call(
            f&#34;/v1/workflows/ga4gh/wes/runs?{urlencode(query_dict)}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def describe(self, project_id: str, tool: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Returns a description of the inputs the workflow engine requires for the given tool

        Parameters
        ----------
        project_id: str
            The project ID
        tool: str
            The tool id or organization/name of the tool to run

        Returns
        -------
        phc.ApiResponse
            The description of the inputs for the given tool
        &#34;&#34;&#34;
        describe_request = {
            &#34;datasetId&#34;: project_id,
            &#34;workflowSourceFileId&#34;: tool,
        }

        return self._api_call(
            &#34;/v1/workflows/ga4gh/wes/runs/parse&#34;,
            json=describe_request,
            http_verb=&#34;POST&#34;,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Workflows.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self, project_id: str, tool: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a description of the inputs the workflow engine requires for the given tool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>tool</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool id or organization/name of the tool to run</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The description of the inputs for the given tool</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, project_id: str, tool: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Returns a description of the inputs the workflow engine requires for the given tool

    Parameters
    ----------
    project_id: str
        The project ID
    tool: str
        The tool id or organization/name of the tool to run

    Returns
    -------
    phc.ApiResponse
        The description of the inputs for the given tool
    &#34;&#34;&#34;
    describe_request = {
        &#34;datasetId&#34;: project_id,
        &#34;workflowSourceFileId&#34;: tool,
    }

    return self._api_call(
        &#34;/v1/workflows/ga4gh/wes/runs/parse&#34;,
        json=describe_request,
        http_verb=&#34;POST&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Workflows.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, project_id: str, workflow_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Get workflow metadata by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>workflow_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The workflow ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get workflow response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, project_id: str, workflow_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Get workflow metadata by id

    Parameters
    ----------
    project_id: str
        The project ID
    workflow_id : str
        The workflow ID.

    Returns
    -------
    phc.ApiResponse
        The get workflow response
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;/v1/workflows/ga4gh/wes/runs/{project_id}:{workflow_id}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Workflows.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, project_id: str, page_size: Optional[int] = 100, next_page_token: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of workflows run in the specified project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default 100</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list workflow run response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    project_id: str,
    page_size: Optional[int] = 100,
    next_page_token: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of workflows run in the specified project

    Parameters
    ----------
    project_id: str
        The project ID
    page_size : int, optional
        The page size, by default 100
    next_page_token : str, optional
        The next page token, by default None

    Returns
    -------
    phc.ApiResponse
        The list workflow run response
    &#34;&#34;&#34;
    query_dict = {&#34;datasetId&#34;: project_id}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token

    return self._api_call(
        f&#34;/v1/workflows/ga4gh/wes/runs?{urlencode(query_dict)}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Workflows.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, project_id: str, name: str, tool: str, workflow_inputs: Optional[str] = None, workflow_inputs_file_id: Optional[str] = None, output_project_folder: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name to give to this run of a tool</dd>
<dt><strong><code>tool</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool id or organization/name of the tool to run</dd>
<dt><strong><code>workflow_inputs</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The inputs required by the workflow as a json string, either this or workflow_inputs_file_id are required</dd>
<dt><strong><code>workflow_inputs_file_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The inputs required by the workflow as provided in a file in PHC, either this or workflow_inputs are required</dd>
<dt><strong><code>output_project_folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The destination output folder in PHC for the workflow run outputs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The workflow run response</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Workflows
&gt;&gt;&gt; workflows = Workflows(session)
&gt;&gt;&gt; workflows.run(project_id=&quot;d2876f48-724f-4987-9cf0-92c7ef99a9fa&quot;,
      name=&quot;Ashion ingest subj: 2405&quot;,
      tool=&quot;lifeomic/ashion-ingest-workflow&quot;,
      workflow_inputs=&quot;{'reference': 'GRCh37','tarFile': {'class': 'File','fileId': '28235c74-9731-4496-bb3c-41c361f106f3'}, 'source': 'incoming/ashion_C043_9999_009990_T1_K1ID2_ps20190814000000.tar.gz'}&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self,
    project_id: str,
    name: str,
    tool: str,
    workflow_inputs: Optional[str] = None,
    workflow_inputs_file_id: Optional[str] = None,
    output_project_folder: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a tool.

    Parameters
    ----------
    project_id: str
        The project ID
    name: str
        The name to give to this run of a tool
    tool: str
        The tool id or organization/name of the tool to run
    workflow_inputs: str, optional
        The inputs required by the workflow as a json string, either this or workflow_inputs_file_id are required
    workflow_inputs_file_id: str, optional
        The inputs required by the workflow as provided in a file in PHC, either this or workflow_inputs are required
    output_project_folder: str, optional
        The destination output folder in PHC for the workflow run outputs

    Returns
    -------
    ApiResponse
        The workflow run response

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Workflows
    &gt;&gt;&gt; workflows = Workflows(session)
    &gt;&gt;&gt; workflows.run(project_id=&#34;d2876f48-724f-4987-9cf0-92c7ef99a9fa&#34;,
          name=&#34;Ashion ingest subj: 2405&#34;,
          tool=&#34;lifeomic/ashion-ingest-workflow&#34;,
          workflow_inputs=&#34;{&#39;reference&#39;: &#39;GRCh37&#39;,&#39;tarFile&#39;: {&#39;class&#39;: &#39;File&#39;,&#39;fileId&#39;: &#39;28235c74-9731-4496-bb3c-41c361f106f3&#39;}, &#39;source&#39;: &#39;incoming/ashion_C043_9999_009990_T1_K1ID2_ps20190814000000.tar.gz&#39;}&#34;)
    &#34;&#34;&#34;
    create_request = {
        &#34;datasetId&#34;: project_id,
        &#34;name&#34;: name,
        &#34;workflowSourceFileId&#34;: tool,
    }

    if workflow_inputs:
        create_request[&#34;workflowInputs&#34;] = workflow_inputs
    elif workflow_inputs_file_id:
        create_request[&#34;workflowInputsFileId&#34;] = workflow_inputs_file_id
    else:
        raise ValueError(
            &#34;Must provide a value for the workflow_inputs or workflow_inputs_file_id&#34;
        )

    if output_project_folder:
        create_request[&#34;outputProjectFolder&#34;] = output_project_folder

    res = self._api_call(
        &#34;/v1/workflows/ga4gh/wes/runs&#34;,
        json=create_request,
        http_verb=&#34;POST&#34;,
    )
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="PHC Home" href="https://lifeomic.github.io/phc-sdk-py/">
<img src="./phc.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phc" href="../index.html">phc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phc.services.Accounts" href="#phc.services.Accounts">Accounts</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Accounts.get_list" href="#phc.services.Accounts.get_list">get_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Analytics" href="#phc.services.Analytics">Analytics</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Analytics.execute_data_lake_query" href="#phc.services.Analytics.execute_data_lake_query">execute_data_lake_query</a></code></li>
<li><code><a title="phc.services.Analytics.execute_data_lake_query_to_dataframe" href="#phc.services.Analytics.execute_data_lake_query_to_dataframe">execute_data_lake_query_to_dataframe</a></code></li>
<li><code><a title="phc.services.Analytics.execute_sql" href="#phc.services.Analytics.execute_sql">execute_sql</a></code></li>
<li><code><a title="phc.services.Analytics.get_data_lake_query" href="#phc.services.Analytics.get_data_lake_query">get_data_lake_query</a></code></li>
<li><code><a title="phc.services.Analytics.get_data_lake_schema" href="#phc.services.Analytics.get_data_lake_schema">get_data_lake_schema</a></code></li>
<li><code><a title="phc.services.Analytics.get_patients" href="#phc.services.Analytics.get_patients">get_patients</a></code></li>
<li><code><a title="phc.services.Analytics.list_data_lake_queries" href="#phc.services.Analytics.list_data_lake_queries">list_data_lake_queries</a></code></li>
<li><code><a title="phc.services.Analytics.list_data_lake_schemas" href="#phc.services.Analytics.list_data_lake_schemas">list_data_lake_schemas</a></code></li>
<li><code><a title="phc.services.Analytics.load_data_lake_result_to_dataframe" href="#phc.services.Analytics.load_data_lake_result_to_dataframe">load_data_lake_result_to_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Cohorts" href="#phc.services.Cohorts">Cohorts</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Cohorts.create" href="#phc.services.Cohorts.create">create</a></code></li>
<li><code><a title="phc.services.Cohorts.delete" href="#phc.services.Cohorts.delete">delete</a></code></li>
<li><code><a title="phc.services.Cohorts.get" href="#phc.services.Cohorts.get">get</a></code></li>
<li><code><a title="phc.services.Cohorts.get_list" href="#phc.services.Cohorts.get_list">get_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Fhir" href="#phc.services.Fhir">Fhir</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Fhir.dsl" href="#phc.services.Fhir.dsl">dsl</a></code></li>
<li><code><a title="phc.services.Fhir.execute_es" href="#phc.services.Fhir.execute_es">execute_es</a></code></li>
<li><code><a title="phc.services.Fhir.execute_sql" href="#phc.services.Fhir.execute_sql">execute_sql</a></code></li>
<li><code><a title="phc.services.Fhir.sql" href="#phc.services.Fhir.sql">sql</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Files" href="#phc.services.Files">Files</a></code></h4>
<ul class="two-column">
<li><code><a title="phc.services.Files.delete" href="#phc.services.Files.delete">delete</a></code></li>
<li><code><a title="phc.services.Files.download" href="#phc.services.Files.download">download</a></code></li>
<li><code><a title="phc.services.Files.exists" href="#phc.services.Files.exists">exists</a></code></li>
<li><code><a title="phc.services.Files.get" href="#phc.services.Files.get">get</a></code></li>
<li><code><a title="phc.services.Files.get_list" href="#phc.services.Files.get_list">get_list</a></code></li>
<li><code><a title="phc.services.Files.update" href="#phc.services.Files.update">update</a></code></li>
<li><code><a title="phc.services.Files.upload" href="#phc.services.Files.upload">upload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Genomics" href="#phc.services.Genomics">Genomics</a></code></h4>
<ul class="two-column">
<li><code><a title="phc.services.Genomics.create_set" href="#phc.services.Genomics.create_set">create_set</a></code></li>
<li><code><a title="phc.services.Genomics.delete_set" href="#phc.services.Genomics.delete_set">delete_set</a></code></li>
<li><code><a title="phc.services.Genomics.delete_test" href="#phc.services.Genomics.delete_test">delete_test</a></code></li>
<li><code><a title="phc.services.Genomics.get_set" href="#phc.services.Genomics.get_set">get_set</a></code></li>
<li><code><a title="phc.services.Genomics.get_test" href="#phc.services.Genomics.get_test">get_test</a></code></li>
<li><code><a title="phc.services.Genomics.list_sets" href="#phc.services.Genomics.list_sets">list_sets</a></code></li>
<li><code><a title="phc.services.Genomics.list_tests" href="#phc.services.Genomics.list_tests">list_tests</a></code></li>
<li><code><a title="phc.services.Genomics.update_set" href="#phc.services.Genomics.update_set">update_set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Projects" href="#phc.services.Projects">Projects</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Projects.create" href="#phc.services.Projects.create">create</a></code></li>
<li><code><a title="phc.services.Projects.delete" href="#phc.services.Projects.delete">delete</a></code></li>
<li><code><a title="phc.services.Projects.get" href="#phc.services.Projects.get">get</a></code></li>
<li><code><a title="phc.services.Projects.get_list" href="#phc.services.Projects.get_list">get_list</a></code></li>
<li><code><a title="phc.services.Projects.update" href="#phc.services.Projects.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Tools" href="#phc.services.Tools">Tools</a></code></h4>
<ul class="two-column">
<li><code><a title="phc.services.Tools.add_version" href="#phc.services.Tools.add_version">add_version</a></code></li>
<li><code><a title="phc.services.Tools.create" href="#phc.services.Tools.create">create</a></code></li>
<li><code><a title="phc.services.Tools.delete" href="#phc.services.Tools.delete">delete</a></code></li>
<li><code><a title="phc.services.Tools.download" href="#phc.services.Tools.download">download</a></code></li>
<li><code><a title="phc.services.Tools.get" href="#phc.services.Tools.get">get</a></code></li>
<li><code><a title="phc.services.Tools.get_list" href="#phc.services.Tools.get_list">get_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Workflows" href="#phc.services.Workflows">Workflows</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Workflows.describe" href="#phc.services.Workflows.describe">describe</a></code></li>
<li><code><a title="phc.services.Workflows.get" href="#phc.services.Workflows.get">get</a></code></li>
<li><code><a title="phc.services.Workflows.get_list" href="#phc.services.Workflows.get_list">get_list</a></code></li>
<li><code><a title="phc.services.Workflows.run" href="#phc.services.Workflows.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
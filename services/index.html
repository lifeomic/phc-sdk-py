<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>phc.services API documentation</title>
<meta name="description" content="Contains services for accessing different parts of the PHC platform." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em;font-family:"Lato",Helvetica,Roboto,Arial,"Lucida Grande",sans-serif}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:90%}ul li code a{font-size:80%}a{color:#00539a;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#f7944d}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" href="./favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phc.services</code></h1>
</header>
<section id="section-intro">
<p>Contains services for accessing different parts of the PHC platform.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains services for accessing different parts of the PHC platform.
&#34;&#34;&#34;

from phc.services.accounts import Accounts
from phc.services.analytics import Analytics
from phc.services.fhir import Fhir
from phc.services.projects import Projects
from phc.services.files import Files
from phc.services.cohorts import Cohorts
from phc.services.genomics import Genomics
from phc.services.tools import Tools
from phc.services.workflows import Workflows
from phc.services.genomic_ingestions import GenomicIngestions, IngestionStep
from phc.services.tasks import Tasks
from phc.services.patient_ml import PatientML

__all__ = [
    &#34;Accounts&#34;,
    &#34;Analytics&#34;,
    &#34;Fhir&#34;,
    &#34;Projects&#34;,
    &#34;Files&#34;,
    &#34;Cohorts&#34;,
    &#34;Genomics&#34;,
    &#34;Tools&#34;,
    &#34;Workflows&#34;,
    &#34;GenomicIngestions&#34;,
    &#34;Tasks&#34;,
    &#34;PatientML&#34;,
]

__pdoc__ = {
    &#34;accounts&#34;: False,
    &#34;analytics&#34;: False,
    &#34;fhir&#34;: False,
    &#34;projects&#34;: False,
    &#34;files&#34;: False,
    &#34;cohorts&#34;: False,
    &#34;genomics&#34;: False,
    &#34;tools&#34;: False,
    &#34;workflows&#34;: False,
    &#34;genomic_ingestions&#34;: False,
    &#34;tasks&#34;: False,
    &#34;patient_ml&#34;: False,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phc.services.Accounts"><code class="flex name class">
<span>class <span class="ident">Accounts</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC accounts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Accounts(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC accounts

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def get_list(self) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetches the list of accounts for the current session

        Returns
        -------
        phc.ApiResponse
            The list accounts response
        &#34;&#34;&#34;
        return self._api_call(&#34;accounts&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Accounts.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches the list of accounts for the current session</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list accounts response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(self) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetches the list of accounts for the current session

    Returns
    -------
    phc.ApiResponse
        The list accounts response
    &#34;&#34;&#34;
    return self._api_call(&#34;accounts&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Analytics"><code class="flex name class">
<span>class <span class="ident">Analytics</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC Analytics</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Analytics(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC Analytics

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def execute_sql(
        self,
        statement: str,
        project_id: Optional[str] = None,
        cohort_id: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a SQL query against Analytics

        Parameters
        ----------
        project_id : str
            The project ID
        cohort_id : str
            The cohort ID
        statement : str
            The SQL statement

        Returns
        -------
        ApiResponse
            The API Response

        Raises
        ------
        ValueError
            If no project or cohort ID is provided

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Analytics
        &gt;&gt;&gt; client = Analytics(session)
        &gt;&gt;&gt; res = client.execute_sql(cohort_id=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, statement=&#39;SELECT patients from patient&#39;)
        &gt;&gt;&gt; print(f&#34;Found {len(res.get(&#39;data&#39;).get(&#39;patients&#39;))} patients&#34;)
        &#34;&#34;&#34;
        if not project_id and not cohort_id:
            raise ValueError(
                &#34;Must provide a value for the project or cohort ID&#34;
            )

        payload = {&#34;string_query&#34;: statement}

        if project_id:
            payload[&#34;dataset_id&#34;] = project_id
        if cohort_id:
            payload[&#34;cohort_id&#34;] = cohort_id

        return self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)

    def get_patients(
        self, project_id: str, query_builder: PatientFilterQueryBuilder
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a query that returns patients

        Parameters
        ----------
        project_id : str
            The project ID
        query_builder : util.PatientFilterQueryBuilder
            The query builder

        Returns
        -------
        list
            The list of patients

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Analytics
        &gt;&gt;&gt; from phc.util import PatientFilterQueryBuilder
        &gt;&gt;&gt; client = Analytics(session)
        &gt;&gt;&gt; search = PatientFilterQueryBuilder()
        &gt;&gt;&gt; search.patient() \
                .observations() \
                .code(eq=&#39;11142-7&#39;) \
                .system(eq=&#39;http://loinc.org&#39;) \
                .value_quantity(lt=40)
        &gt;&gt;&gt; res = client.get_patients(project=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, query_builder=search)
        &gt;&gt;&gt; print(f&#34;Found {len(res)} patients&#34;)
        &#34;&#34;&#34;
        payload = query_builder.to_dict()
        payload[&#34;dataset_id&#34;] = project_id
        return (
            self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)
            .get(&#34;data&#34;)
            .get(&#34;patients&#34;)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Analytics.execute_sql"><code class="name flex">
<span>def <span class="ident">execute_sql</span></span>(<span>self, statement: str, project_id: Optional[str] = None, cohort_id: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a SQL query against Analytics</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>cohort_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort ID</dd>
<dt><strong><code>statement</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL statement</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The API Response</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no project or cohort ID is provided</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Analytics
&gt;&gt;&gt; client = Analytics(session)
&gt;&gt;&gt; res = client.execute_sql(cohort_id='5a07dedb-fa2a-4cb0-b662-95b23a050221', statement='SELECT patients from patient')
&gt;&gt;&gt; print(f&quot;Found {len(res.get('data').get('patients'))} patients&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_sql(
    self,
    statement: str,
    project_id: Optional[str] = None,
    cohort_id: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a SQL query against Analytics

    Parameters
    ----------
    project_id : str
        The project ID
    cohort_id : str
        The cohort ID
    statement : str
        The SQL statement

    Returns
    -------
    ApiResponse
        The API Response

    Raises
    ------
    ValueError
        If no project or cohort ID is provided

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Analytics
    &gt;&gt;&gt; client = Analytics(session)
    &gt;&gt;&gt; res = client.execute_sql(cohort_id=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, statement=&#39;SELECT patients from patient&#39;)
    &gt;&gt;&gt; print(f&#34;Found {len(res.get(&#39;data&#39;).get(&#39;patients&#39;))} patients&#34;)
    &#34;&#34;&#34;
    if not project_id and not cohort_id:
        raise ValueError(
            &#34;Must provide a value for the project or cohort ID&#34;
        )

    payload = {&#34;string_query&#34;: statement}

    if project_id:
        payload[&#34;dataset_id&#34;] = project_id
    if cohort_id:
        payload[&#34;cohort_id&#34;] = cohort_id

    return self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)</code></pre>
</details>
</dd>
<dt id="phc.services.Analytics.get_patients"><code class="name flex">
<span>def <span class="ident">get_patients</span></span>(<span>self, project_id: str, query_builder: phc.util.patient_filter_query_builder.PatientFilterQueryBuilder) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a query that returns patients</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>query_builder</code></strong> :&ensp;<code>util.PatientFilterQueryBuilder</code></dt>
<dd>The query builder</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of patients</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Analytics
&gt;&gt;&gt; from phc.util import PatientFilterQueryBuilder
&gt;&gt;&gt; client = Analytics(session)
&gt;&gt;&gt; search = PatientFilterQueryBuilder()
&gt;&gt;&gt; search.patient()                 .observations()                 .code(eq='11142-7')                 .system(eq='http://loinc.org')                 .value_quantity(lt=40)
&gt;&gt;&gt; res = client.get_patients(project='5a07dedb-fa2a-4cb0-b662-95b23a050221', query_builder=search)
&gt;&gt;&gt; print(f&quot;Found {len(res)} patients&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_patients(
    self, project_id: str, query_builder: PatientFilterQueryBuilder
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a query that returns patients

    Parameters
    ----------
    project_id : str
        The project ID
    query_builder : util.PatientFilterQueryBuilder
        The query builder

    Returns
    -------
    list
        The list of patients

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Analytics
    &gt;&gt;&gt; from phc.util import PatientFilterQueryBuilder
    &gt;&gt;&gt; client = Analytics(session)
    &gt;&gt;&gt; search = PatientFilterQueryBuilder()
    &gt;&gt;&gt; search.patient() \
            .observations() \
            .code(eq=&#39;11142-7&#39;) \
            .system(eq=&#39;http://loinc.org&#39;) \
            .value_quantity(lt=40)
    &gt;&gt;&gt; res = client.get_patients(project=&#39;5a07dedb-fa2a-4cb0-b662-95b23a050221&#39;, query_builder=search)
    &gt;&gt;&gt; print(f&#34;Found {len(res)} patients&#34;)
    &#34;&#34;&#34;
    payload = query_builder.to_dict()
    payload[&#34;dataset_id&#34;] = project_id
    return (
        self._api_call(&#34;analytics/dsl&#34;, http_verb=&#34;POST&#34;, json=payload)
        .get(&#34;data&#34;)
        .get(&#34;patients&#34;)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Cohorts"><code class="flex name class">
<span>class <span class="ident">Cohorts</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC cohorts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cohorts(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC cohorts

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def create(
        self,
        project_id: str,
        name: str,
        queries: list,
        description: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a cohort

        Parameters
        ----------
        project_id: str
            The project that owns the cohort
        name : str
            The cohort name.
        queries: list
            The list of queries that define the cohort
        description : str, optional
            The cohort description, by default None

        Returns
        -------
        phc.ApiResponse
            The create cohort response
        &#34;&#34;&#34;
        json_body = {
            &#34;name&#34;: name,
            &#34;ownerProject&#34;: project_id,
            &#34;queries&#34;: queries,
        }
        if description:
            json_body[&#34;description&#34;] = description
        return self._api_call(&#34;cohorts&#34;, json=json_body, http_verb=&#34;POST&#34;)

    def get(self, cohort_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a cohort by id

        Parameters
        ----------
        cohort_id : str
            The cohort ID.

        Returns
        -------
        phc.ApiResponse
            The get cohort response
        &#34;&#34;&#34;
        return self._api_call(f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;GET&#34;)

    def delete(self, cohort_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a cohort

        Parameters
        ----------
        cohort_id : str
            The cohort ID.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._api_call(
                f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 204
        )

    def get_list(
        self,
        project_id: str,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of cohorts in a project

        Parameters
        ----------
        project_id: str
            The project ID to search within
        page_size : int, optional
            The page size, by default None
        next_page_token : str, optional
            The next page token, by default None
        name : str, optional
            A cohort name filter, by default None

        Returns
        -------
        phc.ApiResponse
            The list cohorts response
        &#34;&#34;&#34;
        query_dict = {&#34;projectId&#34;: project_id}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if name:
            query_dict[&#34;name&#34;] = name
        return self._api_call(
            f&#34;cohorts?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Cohorts.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, project_id: str, name: str, queries: list, description: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a cohort</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project that owns the cohort</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort name.</dd>
<dt><strong><code>queries</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of queries that define the cohort</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The cohort description, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The create cohort response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(
    self,
    project_id: str,
    name: str,
    queries: list,
    description: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a cohort

    Parameters
    ----------
    project_id: str
        The project that owns the cohort
    name : str
        The cohort name.
    queries: list
        The list of queries that define the cohort
    description : str, optional
        The cohort description, by default None

    Returns
    -------
    phc.ApiResponse
        The create cohort response
    &#34;&#34;&#34;
    json_body = {
        &#34;name&#34;: name,
        &#34;ownerProject&#34;: project_id,
        &#34;queries&#34;: queries,
    }
    if description:
        json_body[&#34;description&#34;] = description
    return self._api_call(&#34;cohorts&#34;, json=json_body, http_verb=&#34;POST&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Cohorts.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, cohort_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a cohort</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cohort_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, cohort_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a cohort

    Parameters
    ----------
    cohort_id : str
        The cohort ID.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._api_call(
            f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Cohorts.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, cohort_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a cohort by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cohort_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The cohort ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get cohort response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, cohort_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a cohort by id

    Parameters
    ----------
    cohort_id : str
        The cohort ID.

    Returns
    -------
    phc.ApiResponse
        The get cohort response
    &#34;&#34;&#34;
    return self._api_call(f&#34;cohorts/{cohort_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Cohorts.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, project_id: str, page_size: Optional[int] = None, next_page_token: Optional[str] = None, name: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of cohorts in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to search within</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A cohort name filter, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list cohorts response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    project_id: str,
    page_size: Optional[int] = None,
    next_page_token: Optional[str] = None,
    name: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of cohorts in a project

    Parameters
    ----------
    project_id: str
        The project ID to search within
    page_size : int, optional
        The page size, by default None
    next_page_token : str, optional
        The next page token, by default None
    name : str, optional
        A cohort name filter, by default None

    Returns
    -------
    phc.ApiResponse
        The list cohorts response
    &#34;&#34;&#34;
    query_dict = {&#34;projectId&#34;: project_id}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if name:
        query_dict[&#34;name&#34;] = name
    return self._api_call(
        f&#34;cohorts?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Fhir"><code class="flex name class">
<span>class <span class="ident">Fhir</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides bindings to the LifeOmic FHIR Service APIs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fhir(BaseClient):
    &#34;&#34;&#34;Provides bindings to the LifeOmic FHIR Service APIs&#34;&#34;&#34;

    def dsl(self, project: str, data: dict, scroll=&#34;&#34;):
        &#34;&#34;&#34;Executes a LifeOmic FHIR Service DSL request

        Parameters
        ----------
        project : str
            The target LifeOmic project identifier
        data : dict
            The DSL request object
        scroll
            The scroll request parameter

        Returns
        -------
        phc.ApiResponse
            The API response
        &#34;&#34;&#34;
        path = f&#34;fhir-search/projects/{project}&#34;
        scroll = scroll if scroll is not True else &#34;true&#34;
        params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
        return self._api_call(
            http_verb=&#34;POST&#34;, api_path=path, params=params, json=data
        )

    def sql(self, project: str, statement: str, scroll=&#34;&#34;) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes a LifeOmic FHIR Service SQL request

        Parameters
        ----------
        project : str
            The target LifeOmic project identifier
        statement : str
            The SQL request statement
        scroll
            The scroll request parameter

        Returns
        -------
        phc.ApiResponse
            The API response
        &#34;&#34;&#34;
        path = f&#34;fhir-search/projects/{project}&#34;
        headers = {&#34;Content-Type&#34;: &#34;text/plain&#34;}
        params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
        return self._api_call(
            http_verb=&#34;POST&#34;,
            api_path=path,
            headers=headers,
            params=params,
            data=statement,
        )

    def execute_sql(
        self, project_id: str, statement: str, scroll=&#34;&#34;
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes an SQL query against fhir-searh-service

        Parameters
        ----------
        project_id : str
            The project ID.
        statement : str
            The SQL statement.

        Returns
        -------
        phc.ApiResponse
            The query response.

        Examples
        --------
        &gt;&gt;&gt; import pandas as pd
        &gt;&gt;&gt; from phc.services import Fhir
        &gt;&gt;&gt; fhir = Fhir(session)
        &gt;&gt;&gt; res = fhir.execute_sql(project_id=&#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;,
                       statement=&#39;SELECT * from patient LIMIT 0,5000&#39;)

        &gt;&gt;&gt; resources = list(map(lambda r: r.get(&#34;_source&#34;), res.get(&#34;hits&#34;).get(&#34;hits&#34;)))
        &gt;&gt;&gt; df = pd.DataFrame(resources)
        &#34;&#34;&#34;

        &#34;&#34;&#34;Executes an SQL query against fhir-searh-service
        Returns:
            [List] -- Dictionary with query response
        &#34;&#34;&#34;
        warnings.warn(&#34;Use the sql method instead&#34;, DeprecationWarning)
        return self._api_call(
            api_path=f&#34;fhir-search/projects/{project_id}&#34;,
            http_verb=&#34;POST&#34;,
            data=statement,
            headers={&#34;Content-Type&#34;: &#34;text/plain&#34;},
            params={&#34;scroll&#34;: scroll},
        )

    def execute_es(
        self, project_id: str, query: dict, scroll=&#34;&#34;
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Executes an elasticsearch query against fhir-searh-service

        Parameters
        ----------
        project_id : str
            The project ID
        query : dict
            The ES query dictionary

        Returns
        -------
        phc.ApiResponse
            The query response
        &#34;&#34;&#34;
        warnings.warn(&#34;Use the dsl method instead&#34;, DeprecationWarning)
        return self._api_call(
            api_path=f&#34;fhir-search/projects/{project_id}&#34;,
            http_verb=&#34;POST&#34;,
            json=query,
            params={&#34;scroll&#34;: scroll},
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Fhir.dsl"><code class="name flex">
<span>def <span class="ident">dsl</span></span>(<span>self, project: str, data: dict, scroll='')</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a LifeOmic FHIR Service DSL request</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code></dt>
<dd>The target LifeOmic project identifier</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>The DSL request object</dd>
<dt><strong><code>scroll</code></strong></dt>
<dd>The scroll request parameter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The API response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dsl(self, project: str, data: dict, scroll=&#34;&#34;):
    &#34;&#34;&#34;Executes a LifeOmic FHIR Service DSL request

    Parameters
    ----------
    project : str
        The target LifeOmic project identifier
    data : dict
        The DSL request object
    scroll
        The scroll request parameter

    Returns
    -------
    phc.ApiResponse
        The API response
    &#34;&#34;&#34;
    path = f&#34;fhir-search/projects/{project}&#34;
    scroll = scroll if scroll is not True else &#34;true&#34;
    params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
    return self._api_call(
        http_verb=&#34;POST&#34;, api_path=path, params=params, json=data
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Fhir.execute_es"><code class="name flex">
<span>def <span class="ident">execute_es</span></span>(<span>self, project_id: str, query: dict, scroll='') ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes an elasticsearch query against fhir-searh-service</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>query</code></strong> :&ensp;<code>dict</code></dt>
<dd>The ES query dictionary</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The query response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_es(
    self, project_id: str, query: dict, scroll=&#34;&#34;
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes an elasticsearch query against fhir-searh-service

    Parameters
    ----------
    project_id : str
        The project ID
    query : dict
        The ES query dictionary

    Returns
    -------
    phc.ApiResponse
        The query response
    &#34;&#34;&#34;
    warnings.warn(&#34;Use the dsl method instead&#34;, DeprecationWarning)
    return self._api_call(
        api_path=f&#34;fhir-search/projects/{project_id}&#34;,
        http_verb=&#34;POST&#34;,
        json=query,
        params={&#34;scroll&#34;: scroll},
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Fhir.execute_sql"><code class="name flex">
<span>def <span class="ident">execute_sql</span></span>(<span>self, project_id: str, statement: str, scroll='') ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes an SQL query against fhir-searh-service</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID.</dd>
<dt><strong><code>statement</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The query response.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from phc.services import Fhir
&gt;&gt;&gt; fhir = Fhir(session)
&gt;&gt;&gt; res = fhir.execute_sql(project_id='19e34782-91c4-4143-aaee-2ba81ed0b206',
               statement='SELECT * from patient LIMIT 0,5000')
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; resources = list(map(lambda r: r.get(&quot;_source&quot;), res.get(&quot;hits&quot;).get(&quot;hits&quot;)))
&gt;&gt;&gt; df = pd.DataFrame(resources)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_sql(
    self, project_id: str, statement: str, scroll=&#34;&#34;
) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes an SQL query against fhir-searh-service

    Parameters
    ----------
    project_id : str
        The project ID.
    statement : str
        The SQL statement.

    Returns
    -------
    phc.ApiResponse
        The query response.

    Examples
    --------
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from phc.services import Fhir
    &gt;&gt;&gt; fhir = Fhir(session)
    &gt;&gt;&gt; res = fhir.execute_sql(project_id=&#39;19e34782-91c4-4143-aaee-2ba81ed0b206&#39;,
                   statement=&#39;SELECT * from patient LIMIT 0,5000&#39;)

    &gt;&gt;&gt; resources = list(map(lambda r: r.get(&#34;_source&#34;), res.get(&#34;hits&#34;).get(&#34;hits&#34;)))
    &gt;&gt;&gt; df = pd.DataFrame(resources)
    &#34;&#34;&#34;

    &#34;&#34;&#34;Executes an SQL query against fhir-searh-service
    Returns:
        [List] -- Dictionary with query response
    &#34;&#34;&#34;
    warnings.warn(&#34;Use the sql method instead&#34;, DeprecationWarning)
    return self._api_call(
        api_path=f&#34;fhir-search/projects/{project_id}&#34;,
        http_verb=&#34;POST&#34;,
        data=statement,
        headers={&#34;Content-Type&#34;: &#34;text/plain&#34;},
        params={&#34;scroll&#34;: scroll},
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Fhir.sql"><code class="name flex">
<span>def <span class="ident">sql</span></span>(<span>self, project: str, statement: str, scroll='') ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a LifeOmic FHIR Service SQL request</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>str</code></dt>
<dd>The target LifeOmic project identifier</dd>
<dt><strong><code>statement</code></strong> :&ensp;<code>str</code></dt>
<dd>The SQL request statement</dd>
<dt><strong><code>scroll</code></strong></dt>
<dd>The scroll request parameter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The API response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sql(self, project: str, statement: str, scroll=&#34;&#34;) -&gt; ApiResponse:
    &#34;&#34;&#34;Executes a LifeOmic FHIR Service SQL request

    Parameters
    ----------
    project : str
        The target LifeOmic project identifier
    statement : str
        The SQL request statement
    scroll
        The scroll request parameter

    Returns
    -------
    phc.ApiResponse
        The API response
    &#34;&#34;&#34;
    path = f&#34;fhir-search/projects/{project}&#34;
    headers = {&#34;Content-Type&#34;: &#34;text/plain&#34;}
    params = {&#34;scroll&#34;: scroll if scroll is not True else &#34;true&#34;}
    return self._api_call(
        http_verb=&#34;POST&#34;,
        api_path=path,
        headers=headers,
        params=params,
        data=statement,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Files"><code class="flex name class">
<span>class <span class="ident">Files</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Files(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC files

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    _MULTIPART_MIN_SIZE = 5 * 1024 * 1024
    _MAX_PARTS = 10000

    def upload(
        self,
        project_id: str,
        source: str,
        file_name: Optional[str] = None,
        overwrite: Optional[bool] = False,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Upload a file.

        Parameters
        ----------
        project_id : str
            The project ID
        source : str
            The path of the file to upload
        file_name : str, optional
            The name of the file, If None will default to the actual base file name.
        overwrite : bool, optional
            True to overwrite an existing file of the same name, by default False

        Returns
        -------
        ApiResponse
            The upload file response

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Files
        &gt;&gt;&gt; files = files(session)
        &gt;&gt;&gt; files.upload(project_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, source=&#34;./myfile.txt&#34;, overwrite=True)
        &#34;&#34;&#34;
        file_size = os.path.getsize(source)
        if file_size &gt; self._MULTIPART_MIN_SIZE:
            res = self._api_call(
                &#34;uploads&#34;,
                json={
                    &#34;name&#34;: file_name
                    if file_name is not None
                    else os.path.basename(source),
                    &#34;datasetId&#34;: project_id,
                    &#34;overwrite&#34;: overwrite,
                },
            )
            upload_id = res.get(&#34;uploadId&#34;)
            part_size = max(
                math.ceil(file_size / self._MAX_PARTS), self._MULTIPART_MIN_SIZE
            )
            total_parts = math.ceil(file_size / part_size)
            part = 1
            while part &lt;= total_parts:
                start = (part - 1) * part_size
                end = file_size if part == total_parts else start + part_size
                f = open(source, &#34;rb&#34;)
                f.seek(start)
                data = f.read(end - start)
                f.close()
                part_res = self._api_call(
                    f&#34;uploads/{upload_id}/parts/{part}&#34;, http_verb=&#34;GET&#34;
                )
                self._api_call_impl(
                    http_verb=&#34;PUT&#34;,
                    url=part_res.get(&#34;uploadUrl&#34;),
                    api_path=None,
                    upload_file=data,
                    headers={
                        &#34;Content-Length&#34;: str(end - start),
                        &#34;Authorization&#34;: None,
                        &#34;LifeOmic-Account&#34;: None,
                        &#34;Content-Type&#34;: None,
                    },
                )
                print(f&#34;Upload {part}&#34;)
                part += 1
            self._api_call(f&#34;uploads/{upload_id}&#34;, http_verb=&#34;DELETE&#34;)
            return res
        else:
            res = self._api_call(
                &#34;files&#34;,
                json={
                    &#34;name&#34;: file_name
                    if file_name is not None
                    else os.path.basename(source),
                    &#34;datasetId&#34;: project_id,
                    &#34;overwrite&#34;: overwrite,
                },
            )
            self._api_call_impl(
                http_verb=&#34;PUT&#34;,
                url=res.get(&#34;uploadUrl&#34;),
                api_path=None,
                upload_file=source,
                headers={
                    &#34;Content-Length&#34;: str(file_size),
                    &#34;Authorization&#34;: None,
                    &#34;LifeOmic-Account&#34;: None,
                    &#34;Content-Type&#34;: None,
                },
            )
            return res

    @backoff.on_exception(
        backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
    )
    def download(self, file_id: str, dest_dir: str = os.getcwd()) -&gt; None:
        &#34;&#34;&#34;Download a file

        Parameters
        ----------
        file_id : str
            The file ID
        dest_dir : str, optional
            The local directory to save the file.  Defaults to the current working directory

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Files
        &gt;&gt;&gt; files = files(session)
        &gt;&gt;&gt; files.download(file_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
        &#34;&#34;&#34;
        try:
            res = self._api_call(
                f&#34;files/{file_id}?include=downloadUrl&#34;, http_verb=&#34;GET&#34;
            )
        except ApiError as e:
            if e.response.status_code == 422:
                raise FileArchiveError(
                    &#34;This file is currently archived and is not available for download. Contact LifeOmic support to learn more.&#34;
                ) from None

        file_path = os.path.join(dest_dir, res.get(&#34;name&#34;))
        target_dir = os.path.dirname(file_path)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
        return file_path

    def get(self, file_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a file by id

        Parameters
        ----------
        file_id : str
            The file ID.

        Returns
        -------
        phc.ApiResponse
            The get file response
        &#34;&#34;&#34;
        return self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)

    def update(
        self,
        file_id: str,
        project_id: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Update a files by moving it to a new project or by renaming it.

        Parameters
        ----------
        file_id : str
            The file ID to update.
        project_id : str, optional
            The new project ID for the file.
        name : str, optional
            The new file name

        Returns
        -------
        phc.ApiResponse
            The update file response
        &#34;&#34;&#34;
        if not project_id and not name:
            raise ValueError(
                &#34;Must provide a value for either &#39;project_id&#39; or &#39;name&#39;&#34;
            )

        json_body = {}
        if name:
            json_body[&#34;name&#34;] = name
        if project_id:
            json_body[&#34;datasetId&#34;] = project_id

        try:
            return self._api_call(
                f&#34;files/{file_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
            )
        except ApiError as e:
            if e.response.status_code == 422:
                raise FileArchiveError(
                    &#34;This file is currently archived and cannot be moved. Contact LifeOmic support to learn more.&#34;
                ) from None

    def delete(self, file_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a file

        Parameters
        ----------
        file_id : str
            The file ID.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;DELETE&#34;).status_code
            == 204
        )

    def get_list(
        self,
        project_id: str,
        folder: Optional[str] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of files in a project

        Parameters
        ----------
        project_id: str
            The project ID
        folder: str, optional
            The folder prefix to look for files, by default None
        page_size : int, optional
            The page size, by default None
        next_page_token : str, optional
            The next page token, by default None

        Returns
        -------
        phc.ApiResponse
            The list files response
        &#34;&#34;&#34;
        query_dict = {}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if folder:
            query_dict[&#34;prefix&#34;] = folder

        return self._api_call(
            f&#34;projects/{project_id}/files?{urlencode(query_dict)}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def exists(self, file_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Check if a file exists by id

        Parameters
        ----------
        file_id : str
            The file ID.

        Returns
        -------
        bool
            True if the file exists, false otherwise
        &#34;&#34;&#34;
        try:
            self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)
            return True
        except ApiError as e:
            if e.response.status_code == 404:
                return False
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Files.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, file_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, file_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a file

    Parameters
    ----------
    file_id : str
        The file ID.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;DELETE&#34;).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Files.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, file_id: str, dest_dir: str = '/home/runner/work/phc-sdk-py/phc-sdk-py') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download a file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID</dd>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The local directory to save the file.
Defaults to the current working directory</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Files
&gt;&gt;&gt; files = files(session)
&gt;&gt;&gt; files.download(file_id=&quot;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&quot;, dest_dir=&quot;./mydata&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@backoff.on_exception(
    backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
)
def download(self, file_id: str, dest_dir: str = os.getcwd()) -&gt; None:
    &#34;&#34;&#34;Download a file

    Parameters
    ----------
    file_id : str
        The file ID
    dest_dir : str, optional
        The local directory to save the file.  Defaults to the current working directory

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Files
    &gt;&gt;&gt; files = files(session)
    &gt;&gt;&gt; files.download(file_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
    &#34;&#34;&#34;
    try:
        res = self._api_call(
            f&#34;files/{file_id}?include=downloadUrl&#34;, http_verb=&#34;GET&#34;
        )
    except ApiError as e:
        if e.response.status_code == 422:
            raise FileArchiveError(
                &#34;This file is currently archived and is not available for download. Contact LifeOmic support to learn more.&#34;
            ) from None

    file_path = os.path.join(dest_dir, res.get(&#34;name&#34;))
    target_dir = os.path.dirname(file_path)
    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
    return file_path</code></pre>
</details>
</dd>
<dt id="phc.services.Files.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, file_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a file exists by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the file exists, false otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, file_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Check if a file exists by id

    Parameters
    ----------
    file_id : str
        The file ID.

    Returns
    -------
    bool
        True if the file exists, false otherwise
    &#34;&#34;&#34;
    try:
        self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)
        return True
    except ApiError as e:
        if e.response.status_code == 404:
            return False
        raise e</code></pre>
</details>
</dd>
<dt id="phc.services.Files.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, file_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a file by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get file response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, file_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a file by id

    Parameters
    ----------
    file_id : str
        The file ID.

    Returns
    -------
    phc.ApiResponse
        The get file response
    &#34;&#34;&#34;
    return self._api_call(f&#34;files/{file_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Files.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, project_id: str, folder: Optional[str] = None, page_size: Optional[int] = None, next_page_token: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of files in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The folder prefix to look for files, by default None</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list files response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    project_id: str,
    folder: Optional[str] = None,
    page_size: Optional[int] = None,
    next_page_token: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of files in a project

    Parameters
    ----------
    project_id: str
        The project ID
    folder: str, optional
        The folder prefix to look for files, by default None
    page_size : int, optional
        The page size, by default None
    next_page_token : str, optional
        The next page token, by default None

    Returns
    -------
    phc.ApiResponse
        The list files response
    &#34;&#34;&#34;
    query_dict = {}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if folder:
        query_dict[&#34;prefix&#34;] = folder

    return self._api_call(
        f&#34;projects/{project_id}/files?{urlencode(query_dict)}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Files.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, file_id: str, project_id: Optional[str] = None, name: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Update a files by moving it to a new project or by renaming it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The file ID to update.</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The new project ID for the file.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The new file name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The update file response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(
    self,
    file_id: str,
    project_id: Optional[str] = None,
    name: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Update a files by moving it to a new project or by renaming it.

    Parameters
    ----------
    file_id : str
        The file ID to update.
    project_id : str, optional
        The new project ID for the file.
    name : str, optional
        The new file name

    Returns
    -------
    phc.ApiResponse
        The update file response
    &#34;&#34;&#34;
    if not project_id and not name:
        raise ValueError(
            &#34;Must provide a value for either &#39;project_id&#39; or &#39;name&#39;&#34;
        )

    json_body = {}
    if name:
        json_body[&#34;name&#34;] = name
    if project_id:
        json_body[&#34;datasetId&#34;] = project_id

    try:
        return self._api_call(
            f&#34;files/{file_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
        )
    except ApiError as e:
        if e.response.status_code == 422:
            raise FileArchiveError(
                &#34;This file is currently archived and cannot be moved. Contact LifeOmic support to learn more.&#34;
            ) from None</code></pre>
</details>
</dd>
<dt id="phc.services.Files.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, project_id: str, source: str, file_name: Optional[str] = None, overwrite: Optional[bool] = False) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Upload a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file to upload</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file, If None will default to the actual base file name.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True to overwrite an existing file of the same name, by default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The upload file response</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Files
&gt;&gt;&gt; files = files(session)
&gt;&gt;&gt; files.upload(project_id=&quot;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&quot;, source=&quot;./myfile.txt&quot;, overwrite=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(
    self,
    project_id: str,
    source: str,
    file_name: Optional[str] = None,
    overwrite: Optional[bool] = False,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Upload a file.

    Parameters
    ----------
    project_id : str
        The project ID
    source : str
        The path of the file to upload
    file_name : str, optional
        The name of the file, If None will default to the actual base file name.
    overwrite : bool, optional
        True to overwrite an existing file of the same name, by default False

    Returns
    -------
    ApiResponse
        The upload file response

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Files
    &gt;&gt;&gt; files = files(session)
    &gt;&gt;&gt; files.upload(project_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, source=&#34;./myfile.txt&#34;, overwrite=True)
    &#34;&#34;&#34;
    file_size = os.path.getsize(source)
    if file_size &gt; self._MULTIPART_MIN_SIZE:
        res = self._api_call(
            &#34;uploads&#34;,
            json={
                &#34;name&#34;: file_name
                if file_name is not None
                else os.path.basename(source),
                &#34;datasetId&#34;: project_id,
                &#34;overwrite&#34;: overwrite,
            },
        )
        upload_id = res.get(&#34;uploadId&#34;)
        part_size = max(
            math.ceil(file_size / self._MAX_PARTS), self._MULTIPART_MIN_SIZE
        )
        total_parts = math.ceil(file_size / part_size)
        part = 1
        while part &lt;= total_parts:
            start = (part - 1) * part_size
            end = file_size if part == total_parts else start + part_size
            f = open(source, &#34;rb&#34;)
            f.seek(start)
            data = f.read(end - start)
            f.close()
            part_res = self._api_call(
                f&#34;uploads/{upload_id}/parts/{part}&#34;, http_verb=&#34;GET&#34;
            )
            self._api_call_impl(
                http_verb=&#34;PUT&#34;,
                url=part_res.get(&#34;uploadUrl&#34;),
                api_path=None,
                upload_file=data,
                headers={
                    &#34;Content-Length&#34;: str(end - start),
                    &#34;Authorization&#34;: None,
                    &#34;LifeOmic-Account&#34;: None,
                    &#34;Content-Type&#34;: None,
                },
            )
            print(f&#34;Upload {part}&#34;)
            part += 1
        self._api_call(f&#34;uploads/{upload_id}&#34;, http_verb=&#34;DELETE&#34;)
        return res
    else:
        res = self._api_call(
            &#34;files&#34;,
            json={
                &#34;name&#34;: file_name
                if file_name is not None
                else os.path.basename(source),
                &#34;datasetId&#34;: project_id,
                &#34;overwrite&#34;: overwrite,
            },
        )
        self._api_call_impl(
            http_verb=&#34;PUT&#34;,
            url=res.get(&#34;uploadUrl&#34;),
            api_path=None,
            upload_file=source,
            headers={
                &#34;Content-Length&#34;: str(file_size),
                &#34;Authorization&#34;: None,
                &#34;LifeOmic-Account&#34;: None,
                &#34;Content-Type&#34;: None,
            },
        )
        return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.GenomicIngestions"><code class="flex name class">
<span>class <span class="ident">GenomicIngestions</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides access to PHC Genomic Ingestions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session.</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False).</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30).</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenomicIngestions(BaseClient):
    &#34;&#34;&#34;Provides access to PHC Genomic Ingestions

    Parameters
    ----------
    session: phc.Session
        The PHC session.
    run_async: bool
        True to return promises, False to return results (default is False).
    timeout: int
        Operation timeout (default is 30).
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default).
    &#34;&#34;&#34;

    def get(self, ingestion_id: str, project_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch an ingestion by id

        Parameters
        ----------
        ingestion_id: str
            The ingestion ID.
        project_id: str
            The project ID for the ingestion.

        Returns
        -------
        phc.ApiResponse
            The get ingestion response.
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions/{ingestion_id}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def list(
        self,
        project_id: str,
        name: Optional[str] = None,
        failed: Optional[bool] = None,
        step: Optional[IngestionStep] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of ingestions in a project

        Parameters
        ----------
        project_id: str
            The project ID for the ingestions.
        name: str, optional
            The name to filter ingestions by, by default None.
        failed: bool, optional
            The status of the ingestions to filter by, by default None.
        step: IngestionStep, optional
            The ingestion steps to filter by, by default None.
        page_size: int, optional
            The page size, by default None.
        next_page_token: str, optional
            The next page token, by default None.

        Returns
        -------
        phc.ApiResponse
            The list ingestions response.
        &#34;&#34;&#34;
        query_dict: Dict[str, Union[str, int, bool]] = {}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if name:
            query_dict[&#34;name&#34;] = name
        if failed is not None:
            query_dict[&#34;failed&#34;] = &#34;true&#34; if failed else &#34;false&#34;
        if step:
            query_dict[&#34;steps&#34;] = step.value

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            http_verb=&#34;GET&#34;,
            params=query_dict,
        )

    def create_foundation(
        self,
        project_id: str,
        xml_file_id: str,
        report_file_id: str,
        vcf_file_id: Optional[str] = None,
        succeeded_email: Optional[str] = None,
        failed_email: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a Foundation ingestion in a project

        Parameters
        ----------
        project_id: str
            The project ID to create the ingestion in.
        xml_file_id: str
            The ID of the XML file to ingest.
        report_file_id: str
            The ID of the Report file to ingest.
        vcf_file_id: str, optional
            The ID of the VCF file to ingest, by default None.
        succeeded_email: str, optional
            The email address to notify if the ingestion succeeds, by default None.
        failed_email: str, optional
            The email address to notify if the ingestion fails, by default None.

        Returns
        phc.ApiResponse
            The ingestion that was created.
        &#34;&#34;&#34;

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            json={
                &#34;ingestionType&#34;: &#34;Foundation&#34;,
                &#34;inputFiles&#34;: {
                    &#34;xml&#34;: xml_file_id,
                    &#34;vcf&#34;: vcf_file_id,
                    &#34;report&#34;: report_file_id,
                },
                &#34;notificationConfig&#34;: {
                    &#34;succeededEmail&#34;: succeeded_email,
                    &#34;failedEmail&#34;: failed_email,
                },
            },
        )

    def create_caris(
        self,
        project_id: str,
        tar_file_id: str,
        succeeded_email: Optional[str] = None,
        failed_email: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a Caris ingestion in a project

        Parameters
        ----------
        project_id: str
            The project ID to create the ingestion in.
        tar_file_id: str
            The ID of the TAR file to ingest.
        succeeded_email: str, optional
            The email address to notify if the ingestion succeeds, by default None.
        failed_email: str, optional
            The email address to notify if the ingestion fails, by default None.

        Returns
        phc.ApiResponse
            The ingestion that was created.
        &#34;&#34;&#34;

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            json={
                &#34;ingestionType&#34;: &#34;Caris&#34;,
                &#34;inputFiles&#34;: {&#34;tar&#34;: tar_file_id},
                &#34;notificationConfig&#34;: {
                    &#34;succeededEmail&#34;: succeeded_email,
                    &#34;failedEmail&#34;: failed_email,
                },
            },
        )

    def create_foundation_bam(
        self,
        project_id: str,
        bam_file_id: str,
        succeeded_email: Optional[str] = None,
        failed_email: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a Foundation BAM ingestion in a project

        Parameters
        ----------
        project_id: str
            The project ID to create the ingestion in.
        bam_file_id: str
            The ID of the BAM file to ingest.
        succeeded_email: str, optional
            The email address to notify if the ingestion succeeds, by default None.
        failed_email: str, optional
            The email address to notify if the ingestion fails, by default None.

        Returns
        phc.ApiResponse
            The ingestion that was created.
        &#34;&#34;&#34;

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            json={
                &#34;ingestionType&#34;: &#34;FoundationBam&#34;,
                &#34;inputFiles&#34;: {&#34;bam&#34;: bam_file_id},
                &#34;notificationConfig&#34;: {
                    &#34;succeededEmail&#34;: succeeded_email,
                    &#34;failedEmail&#34;: failed_email,
                },
            },
        )

    def create_caris_bam(
        self,
        project_id: str,
        bam_file_id: str,
        succeeded_email: Optional[str] = None,
        failed_email: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a Caris BAM ingestion in a project

        Parameters
        ----------
        project_id: str
            The project ID to create the ingestion in.
        bam_file_id: str
            The ID of the BAM file to ingest.
        succeeded_email: str, optional
            The email address to notify if the ingestion succeeds, by default None.
        failed_email: str, optional
            The email address to notify if the ingestion fails, by default None.

        Returns
        phc.ApiResponse
            The ingestion that was created.
        &#34;&#34;&#34;

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            json={
                &#34;ingestionType&#34;: &#34;CarisBam&#34;,
                &#34;inputFiles&#34;: {&#34;bam&#34;: bam_file_id},
                &#34;notificationConfig&#34;: {
                    &#34;succeededEmail&#34;: succeeded_email,
                    &#34;failedEmail&#34;: failed_email,
                },
            },
        )

    def create_nextgen(
        self,
        project_id: str,
        tar_file_id: str,
        succeeded_email: Optional[str] = None,
        failed_email: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a NextGen ingestion in a project

        Parameters
        ----------
        project_id: str
            The project ID to create the ingestion in.
        tar_file_id: str
            The ID of the TAR file to ingest.
        succeeded_email: str, optional
            The email address to notify if the ingestion succeeds, by default None.
        failed_email: str, optional
            The email address to notify if the ingestion fails, by default None.

        Returns
        phc.ApiResponse
            The ingestion that was created.
        &#34;&#34;&#34;

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            json={
                &#34;ingestionType&#34;: &#34;NextGen&#34;,
                &#34;inputFiles&#34;: {&#34;tar&#34;: tar_file_id},
                &#34;notificationConfig&#34;: {
                    &#34;succeededEmail&#34;: succeeded_email,
                    &#34;failedEmail&#34;: failed_email,
                },
            },
        )

    def create_vcf(
        self,
        project_id: str,
        vcf_file_id: str,
        manifest_file_id: str,
        succeeded_email: Optional[str] = None,
        failed_email: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a VCF ingestion in a project

        Parameters
        ----------
        project_id: str
            The project ID to create the ingestion in.
        vcf_file_id: str
            The ID of the VCF file to ingest.
        manifest_file_id: str
            The ID of the manifest file to ingest.
        succeeded_email: str, optional
            The email address to notify if the ingestion succeeds, by default None.
        failed_email: str, optional
            The email address to notify if the ingestion fails, by default None.

        Returns
        -------
        phc.ApiResponse
            The ingestion that was created.
        &#34;&#34;&#34;

        return self._api_call(
            f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
            json={
                &#34;ingestionType&#34;: &#34;Vcf&#34;,
                &#34;inputFiles&#34;: {
                    &#34;vcf&#34;: vcf_file_id,
                    &#34;manifest&#34;: manifest_file_id,
                },
                &#34;notificationConfig&#34;: {
                    &#34;succeededEmail&#34;: succeeded_email,
                    &#34;failedEmail&#34;: failed_email,
                },
            },
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.GenomicIngestions.create_caris"><code class="name flex">
<span>def <span class="ident">create_caris</span></span>(<span>self, project_id: str, tar_file_id: str, succeeded_email: Optional[str] = None, failed_email: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Caris ingestion in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to create the ingestion in.</dd>
<dt><strong><code>tar_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the TAR file to ingest.</dd>
<dt><strong><code>succeeded_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion succeeds, by default None.</dd>
<dt><strong><code>failed_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion fails, by default None.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>phc.ApiResponse
The ingestion that was created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_caris(
    self,
    project_id: str,
    tar_file_id: str,
    succeeded_email: Optional[str] = None,
    failed_email: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a Caris ingestion in a project

    Parameters
    ----------
    project_id: str
        The project ID to create the ingestion in.
    tar_file_id: str
        The ID of the TAR file to ingest.
    succeeded_email: str, optional
        The email address to notify if the ingestion succeeds, by default None.
    failed_email: str, optional
        The email address to notify if the ingestion fails, by default None.

    Returns
    phc.ApiResponse
        The ingestion that was created.
    &#34;&#34;&#34;

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        json={
            &#34;ingestionType&#34;: &#34;Caris&#34;,
            &#34;inputFiles&#34;: {&#34;tar&#34;: tar_file_id},
            &#34;notificationConfig&#34;: {
                &#34;succeededEmail&#34;: succeeded_email,
                &#34;failedEmail&#34;: failed_email,
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.create_caris_bam"><code class="name flex">
<span>def <span class="ident">create_caris_bam</span></span>(<span>self, project_id: str, bam_file_id: str, succeeded_email: Optional[str] = None, failed_email: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Caris BAM ingestion in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to create the ingestion in.</dd>
<dt><strong><code>bam_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the BAM file to ingest.</dd>
<dt><strong><code>succeeded_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion succeeds, by default None.</dd>
<dt><strong><code>failed_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion fails, by default None.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>phc.ApiResponse
The ingestion that was created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_caris_bam(
    self,
    project_id: str,
    bam_file_id: str,
    succeeded_email: Optional[str] = None,
    failed_email: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a Caris BAM ingestion in a project

    Parameters
    ----------
    project_id: str
        The project ID to create the ingestion in.
    bam_file_id: str
        The ID of the BAM file to ingest.
    succeeded_email: str, optional
        The email address to notify if the ingestion succeeds, by default None.
    failed_email: str, optional
        The email address to notify if the ingestion fails, by default None.

    Returns
    phc.ApiResponse
        The ingestion that was created.
    &#34;&#34;&#34;

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        json={
            &#34;ingestionType&#34;: &#34;CarisBam&#34;,
            &#34;inputFiles&#34;: {&#34;bam&#34;: bam_file_id},
            &#34;notificationConfig&#34;: {
                &#34;succeededEmail&#34;: succeeded_email,
                &#34;failedEmail&#34;: failed_email,
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.create_foundation"><code class="name flex">
<span>def <span class="ident">create_foundation</span></span>(<span>self, project_id: str, xml_file_id: str, report_file_id: str, vcf_file_id: Optional[str] = None, succeeded_email: Optional[str] = None, failed_email: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Foundation ingestion in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to create the ingestion in.</dd>
<dt><strong><code>xml_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the XML file to ingest.</dd>
<dt><strong><code>report_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the Report file to ingest.</dd>
<dt><strong><code>vcf_file_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The ID of the VCF file to ingest, by default None.</dd>
<dt><strong><code>succeeded_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion succeeds, by default None.</dd>
<dt><strong><code>failed_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion fails, by default None.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>phc.ApiResponse
The ingestion that was created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_foundation(
    self,
    project_id: str,
    xml_file_id: str,
    report_file_id: str,
    vcf_file_id: Optional[str] = None,
    succeeded_email: Optional[str] = None,
    failed_email: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a Foundation ingestion in a project

    Parameters
    ----------
    project_id: str
        The project ID to create the ingestion in.
    xml_file_id: str
        The ID of the XML file to ingest.
    report_file_id: str
        The ID of the Report file to ingest.
    vcf_file_id: str, optional
        The ID of the VCF file to ingest, by default None.
    succeeded_email: str, optional
        The email address to notify if the ingestion succeeds, by default None.
    failed_email: str, optional
        The email address to notify if the ingestion fails, by default None.

    Returns
    phc.ApiResponse
        The ingestion that was created.
    &#34;&#34;&#34;

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        json={
            &#34;ingestionType&#34;: &#34;Foundation&#34;,
            &#34;inputFiles&#34;: {
                &#34;xml&#34;: xml_file_id,
                &#34;vcf&#34;: vcf_file_id,
                &#34;report&#34;: report_file_id,
            },
            &#34;notificationConfig&#34;: {
                &#34;succeededEmail&#34;: succeeded_email,
                &#34;failedEmail&#34;: failed_email,
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.create_foundation_bam"><code class="name flex">
<span>def <span class="ident">create_foundation_bam</span></span>(<span>self, project_id: str, bam_file_id: str, succeeded_email: Optional[str] = None, failed_email: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Foundation BAM ingestion in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to create the ingestion in.</dd>
<dt><strong><code>bam_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the BAM file to ingest.</dd>
<dt><strong><code>succeeded_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion succeeds, by default None.</dd>
<dt><strong><code>failed_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion fails, by default None.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>phc.ApiResponse
The ingestion that was created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_foundation_bam(
    self,
    project_id: str,
    bam_file_id: str,
    succeeded_email: Optional[str] = None,
    failed_email: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a Foundation BAM ingestion in a project

    Parameters
    ----------
    project_id: str
        The project ID to create the ingestion in.
    bam_file_id: str
        The ID of the BAM file to ingest.
    succeeded_email: str, optional
        The email address to notify if the ingestion succeeds, by default None.
    failed_email: str, optional
        The email address to notify if the ingestion fails, by default None.

    Returns
    phc.ApiResponse
        The ingestion that was created.
    &#34;&#34;&#34;

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        json={
            &#34;ingestionType&#34;: &#34;FoundationBam&#34;,
            &#34;inputFiles&#34;: {&#34;bam&#34;: bam_file_id},
            &#34;notificationConfig&#34;: {
                &#34;succeededEmail&#34;: succeeded_email,
                &#34;failedEmail&#34;: failed_email,
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.create_nextgen"><code class="name flex">
<span>def <span class="ident">create_nextgen</span></span>(<span>self, project_id: str, tar_file_id: str, succeeded_email: Optional[str] = None, failed_email: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a NextGen ingestion in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to create the ingestion in.</dd>
<dt><strong><code>tar_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the TAR file to ingest.</dd>
<dt><strong><code>succeeded_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion succeeds, by default None.</dd>
<dt><strong><code>failed_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion fails, by default None.</dd>
<dt><strong><code>Returns</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>phc.ApiResponse
The ingestion that was created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_nextgen(
    self,
    project_id: str,
    tar_file_id: str,
    succeeded_email: Optional[str] = None,
    failed_email: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a NextGen ingestion in a project

    Parameters
    ----------
    project_id: str
        The project ID to create the ingestion in.
    tar_file_id: str
        The ID of the TAR file to ingest.
    succeeded_email: str, optional
        The email address to notify if the ingestion succeeds, by default None.
    failed_email: str, optional
        The email address to notify if the ingestion fails, by default None.

    Returns
    phc.ApiResponse
        The ingestion that was created.
    &#34;&#34;&#34;

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        json={
            &#34;ingestionType&#34;: &#34;NextGen&#34;,
            &#34;inputFiles&#34;: {&#34;tar&#34;: tar_file_id},
            &#34;notificationConfig&#34;: {
                &#34;succeededEmail&#34;: succeeded_email,
                &#34;failedEmail&#34;: failed_email,
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.create_vcf"><code class="name flex">
<span>def <span class="ident">create_vcf</span></span>(<span>self, project_id: str, vcf_file_id: str, manifest_file_id: str, succeeded_email: Optional[str] = None, failed_email: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a VCF ingestion in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID to create the ingestion in.</dd>
<dt><strong><code>vcf_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the VCF file to ingest.</dd>
<dt><strong><code>manifest_file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the manifest file to ingest.</dd>
<dt><strong><code>succeeded_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion succeeds, by default None.</dd>
<dt><strong><code>failed_email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email address to notify if the ingestion fails, by default None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The ingestion that was created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_vcf(
    self,
    project_id: str,
    vcf_file_id: str,
    manifest_file_id: str,
    succeeded_email: Optional[str] = None,
    failed_email: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a VCF ingestion in a project

    Parameters
    ----------
    project_id: str
        The project ID to create the ingestion in.
    vcf_file_id: str
        The ID of the VCF file to ingest.
    manifest_file_id: str
        The ID of the manifest file to ingest.
    succeeded_email: str, optional
        The email address to notify if the ingestion succeeds, by default None.
    failed_email: str, optional
        The email address to notify if the ingestion fails, by default None.

    Returns
    -------
    phc.ApiResponse
        The ingestion that was created.
    &#34;&#34;&#34;

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        json={
            &#34;ingestionType&#34;: &#34;Vcf&#34;,
            &#34;inputFiles&#34;: {
                &#34;vcf&#34;: vcf_file_id,
                &#34;manifest&#34;: manifest_file_id,
            },
            &#34;notificationConfig&#34;: {
                &#34;succeededEmail&#34;: succeeded_email,
                &#34;failedEmail&#34;: failed_email,
            },
        },
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, ingestion_id: str, project_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch an ingestion by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ingestion_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The ingestion ID.</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID for the ingestion.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get ingestion response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, ingestion_id: str, project_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch an ingestion by id

    Parameters
    ----------
    ingestion_id: str
        The ingestion ID.
    project_id: str
        The project ID for the ingestion.

    Returns
    -------
    phc.ApiResponse
        The get ingestion response.
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions/{ingestion_id}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.GenomicIngestions.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, project_id: str, name: Optional[str] = None, failed: Optional[bool] = None, step: Optional[phc.services.genomic_ingestions.IngestionStep] = None, page_size: Optional[int] = None, next_page_token: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of ingestions in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID for the ingestions.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name to filter ingestions by, by default None.</dd>
<dt><strong><code>failed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The status of the ingestions to filter by, by default None.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>IngestionStep</code>, optional</dt>
<dd>The ingestion steps to filter by, by default None.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None.</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list ingestions response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(
    self,
    project_id: str,
    name: Optional[str] = None,
    failed: Optional[bool] = None,
    step: Optional[IngestionStep] = None,
    page_size: Optional[int] = None,
    next_page_token: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of ingestions in a project

    Parameters
    ----------
    project_id: str
        The project ID for the ingestions.
    name: str, optional
        The name to filter ingestions by, by default None.
    failed: bool, optional
        The status of the ingestions to filter by, by default None.
    step: IngestionStep, optional
        The ingestion steps to filter by, by default None.
    page_size: int, optional
        The page size, by default None.
    next_page_token: str, optional
        The next page token, by default None.

    Returns
    -------
    phc.ApiResponse
        The list ingestions response.
    &#34;&#34;&#34;
    query_dict: Dict[str, Union[str, int, bool]] = {}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if name:
        query_dict[&#34;name&#34;] = name
    if failed is not None:
        query_dict[&#34;failed&#34;] = &#34;true&#34; if failed else &#34;false&#34;
    if step:
        query_dict[&#34;steps&#34;] = step.value

    return self._api_call(
        f&#34;genomic-ingestion/projects/{project_id}/ingestions&#34;,
        http_verb=&#34;GET&#34;,
        params=query_dict,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Genomics"><code class="flex name class">
<span>class <span class="ident">Genomics</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC genomic resources</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Genomics(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC genomic resources

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    class SetType(Enum):
        VARIANT = &#34;variantsets&#34;
        STRUCTURAL_VARIANT = &#34;fusionsets&#34;
        RNA = &#34;rnaquantificationsets&#34;
        READ = &#34;readgroupsets&#34;
        COPY_NUMBER = &#34;copynumbersets&#34;

    class Reference(Enum):
        GRCh37 = &#34;GRCh37&#34;
        GRCh38 = &#34;GRCh38&#34;

    class SequenceType(Enum):
        GERMLINE = &#34;germline&#34;
        SOMATIC = &#34;somatic&#34;
        METASTATIC = &#34;metastatic&#34;
        CTDNA = &#34;ctDNA&#34;
        RNA = &#34;rna&#34;

    class Status(Enum):
        ACTIVE = &#34;ACTIVE&#34;
        INDEXING = &#34;INDEXING&#34;
        FAILED = &#34;FAILED&#34;

    def create_set(
        self,
        set_type: SetType,
        project_id: str,
        name: str,
        file_id: str,
        patient_id: str,
        reference: Reference,
        sequence_type: SequenceType,
        test_type: str,
        sequence_id: Optional[str] = str(uuid.uuid4()),
        indexed_date: Optional[datetime] = None,
        performer_id: Optional[str] = None,
        test_id: Optional[str] = None,
        update_sample: Optional[bool] = False,
        pass_filter: Optional[bool] = False,
        output_vcf_name: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a genomic set

        Parameters
        ----------
        set_type : SetType
            The genomic set type
        project_id : str
            The project ID
        name : str
            The set name
        file_id : str
            The genomic file ID
        patient_id : str
            The patient ID
        reference : Reference
            The genomic reference
        sequence_type : SequenceType
            The sequence type
        test_type : str
            The test type
        sequence_id : str, optional
            The FHIR Sequence ID, by default str(uuid.uuid4())
        indexed_date : datetime, optional
            The indexed date, by default None
        performer_id : str, optional
            The performer ID, by default None
        test_id : str, optional
            The test ID, by default None
        update_sample : bool, optional
            For variants only, True to update the sample ID, by default False
        pass_filter : bool, optional
            For variants only, True to update all filters to pass, by default False
        output_vcf_name : str, optional
            For variants only, the name of the output VCF, by default None

        Returns
        -------
        ApiResponse
            The create set response
        &#34;&#34;&#34;
        json_body = {
            &#34;datasetId&#34;: project_id,
            &#34;name&#34;: name,
            &#34;patientId&#34;: patient_id,
            &#34;referenceSetId&#34;: reference.value,
            &#34;sequenceType&#34;: sequence_type.value,
            &#34;testType&#34;: test_type,
            &#34;indexedDate&#34;: indexed_date.isoformat() if indexed_date else None,
            &#34;performerId&#34;: performer_id,
            &#34;testId&#34;: test_id,
            &#34;sequenceId&#34;: sequence_id,
        }

        if set_type == Genomics.SetType.VARIANT:
            json_body[&#34;variantsFileIds&#34;] = [file_id]
            json_body[&#34;updateSample&#34;] = update_sample
            json_body[&#34;passFile&#34;] = pass_filter
            json_body[&#34;outputVcfName&#34;] = output_vcf_name

            return self._ga4gh_call(
                &#34;genomicsets&#34;, json=json_body, http_verb=&#34;POST&#34;
            )
        else:
            json_body[&#34;fileId&#34;] = file_id

            return self._ga4gh_call(
                set_type.value, json=json_body, http_verb=&#34;POST&#34;
            )

    def update_set(
        self, set_type: SetType, set_id: str, updates: dict
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Update a genomic set

        Parameters
        ----------
        set_type : SetType
            The set type
        set_id : str
            The set ID
        updates : dict
            The updates to apply

        Returns
        -------
        ApiResponse
            The fetch response
        &#34;&#34;&#34;
        return self._ga4gh_call(
            f&#34;{set_type.value}/{set_id}&#34;, json=updates, http_verb=&#34;PATCH&#34;
        )

    def get_set(self, set_type: SetType, set_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a genomic set

        Parameters
        ----------
        set_type : SetType
            The set type
        set_id : str
            The set ID

        Returns
        -------
        ApiResponse
            The fetch response
        &#34;&#34;&#34;
        return self._ga4gh_call(f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;GET&#34;)

    def delete_set(self, set_type: SetType, set_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a genomic set

        Parameters
        ----------
        set_type : SetType
            The set type
        set_id : str
            The set ID

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._ga4gh_call(
                f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 204
        )

    def list_sets(
        self,
        set_type: SetType,
        project_id: str,
        sequence_id: Optional[str] = None,
        patient_id: Optional[str] = None,
        status: Optional[Status] = None,
        next_page_token: Optional[str] = None,
        page_size: Optional[int] = 50,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;List genomic sets

        Parameters
        ----------
        set_type : SetType
            The set type
        project_id : str
            The project ID
        sequence_id : str, optional
            List sets by sequence ID, by default None
        patient_id : str, optional
            List sets by patient ID, by default None
        status : Status, optional
            Filter sets by status, by default None
        next_page_token : str, optional
            The next page token, by default None
        page_size : int, optional
            The page size, by default 50

        Returns
        -------
        ApiResponse
            The list sets response
        &#34;&#34;&#34;

        json_body = {
            &#34;datasetIds&#34;: [project_id],
            &#34;status&#34;: status,
            &#34;patientId&#34;: patient_id,
            &#34;sequenceId&#34;: sequence_id,
            &#34;pageSize&#34;: page_size,
            &#34;pageToken&#34;: next_page_token,
        }

        return self._ga4gh_call(
            f&#34;{set_type.value}/search&#34;, json=json_body, http_verb=&#34;POST&#34;
        )

    def list_tests(self, project_id: str, patient_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;List tests for a patient

        Parameters
        ----------
        project_id : str
            The project ID
        patient_id : str
            The patient ID

        Returns
        -------
        ApiResponse
            The list tests response
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;genomics/projects/{project_id}/subjects/{patient_id}/tests&#34;,
            http_verb=&#34;GET&#34;,
        )

    def get_test(self, project_id: str, test_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Get test by project and test id

        Parameters
        ----------
        project_id : str
            The project ID
        test_id : str
            The Test ID

        Returns
        -------
        ApiResponse
            The get test response
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;, http_verb=&#34;GET&#34;
        )

    def delete_test(self, project_id: str, test_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a genomic test

        Parameters
        ----------
        project_id : SetType
            The project ID
        test_id : str
            The test ID

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._ga4gh_call(
                f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;,
                http_verb=&#34;DELETE&#34;,
            ).status_code
            == 204
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="phc.services.Genomics.Reference"><code class="name">var <span class="ident">Reference</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="phc.services.Genomics.SequenceType"><code class="name">var <span class="ident">SequenceType</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="phc.services.Genomics.SetType"><code class="name">var <span class="ident">SetType</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
<dt id="phc.services.Genomics.Status"><code class="name">var <span class="ident">Status</span></code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Genomics.create_set"><code class="name flex">
<span>def <span class="ident">create_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, project_id: str, name: str, file_id: str, patient_id: str, reference: phc.services.genomics.Genomics.Reference, sequence_type: phc.services.genomics.Genomics.SequenceType, test_type: str, sequence_id: Optional[str] = '72ded3cc-d36f-45fb-9972-663704f3a827', indexed_date: Optional[datetime.datetime] = None, performer_id: Optional[str] = None, test_id: Optional[str] = None, update_sample: Optional[bool] = False, pass_filter: Optional[bool] = False, output_vcf_name: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The genomic set type</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The set name</dd>
<dt><strong><code>file_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The genomic file ID</dd>
<dt><strong><code>patient_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The patient ID</dd>
<dt><strong><code>reference</code></strong> :&ensp;<code>Reference</code></dt>
<dd>The genomic reference</dd>
<dt><strong><code>sequence_type</code></strong> :&ensp;<code>SequenceType</code></dt>
<dd>The sequence type</dd>
<dt><strong><code>test_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The test type</dd>
<dt><strong><code>sequence_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The FHIR Sequence ID, by default str(uuid.uuid4())</dd>
<dt><strong><code>indexed_date</code></strong> :&ensp;<code>datetime</code>, optional</dt>
<dd>The indexed date, by default None</dd>
<dt><strong><code>performer_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The performer ID, by default None</dd>
<dt><strong><code>test_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The test ID, by default None</dd>
<dt><strong><code>update_sample</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>For variants only, True to update the sample ID, by default False</dd>
<dt><strong><code>pass_filter</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>For variants only, True to update all filters to pass, by default False</dd>
<dt><strong><code>output_vcf_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>For variants only, the name of the output VCF, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The create set response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_set(
    self,
    set_type: SetType,
    project_id: str,
    name: str,
    file_id: str,
    patient_id: str,
    reference: Reference,
    sequence_type: SequenceType,
    test_type: str,
    sequence_id: Optional[str] = str(uuid.uuid4()),
    indexed_date: Optional[datetime] = None,
    performer_id: Optional[str] = None,
    test_id: Optional[str] = None,
    update_sample: Optional[bool] = False,
    pass_filter: Optional[bool] = False,
    output_vcf_name: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a genomic set

    Parameters
    ----------
    set_type : SetType
        The genomic set type
    project_id : str
        The project ID
    name : str
        The set name
    file_id : str
        The genomic file ID
    patient_id : str
        The patient ID
    reference : Reference
        The genomic reference
    sequence_type : SequenceType
        The sequence type
    test_type : str
        The test type
    sequence_id : str, optional
        The FHIR Sequence ID, by default str(uuid.uuid4())
    indexed_date : datetime, optional
        The indexed date, by default None
    performer_id : str, optional
        The performer ID, by default None
    test_id : str, optional
        The test ID, by default None
    update_sample : bool, optional
        For variants only, True to update the sample ID, by default False
    pass_filter : bool, optional
        For variants only, True to update all filters to pass, by default False
    output_vcf_name : str, optional
        For variants only, the name of the output VCF, by default None

    Returns
    -------
    ApiResponse
        The create set response
    &#34;&#34;&#34;
    json_body = {
        &#34;datasetId&#34;: project_id,
        &#34;name&#34;: name,
        &#34;patientId&#34;: patient_id,
        &#34;referenceSetId&#34;: reference.value,
        &#34;sequenceType&#34;: sequence_type.value,
        &#34;testType&#34;: test_type,
        &#34;indexedDate&#34;: indexed_date.isoformat() if indexed_date else None,
        &#34;performerId&#34;: performer_id,
        &#34;testId&#34;: test_id,
        &#34;sequenceId&#34;: sequence_id,
    }

    if set_type == Genomics.SetType.VARIANT:
        json_body[&#34;variantsFileIds&#34;] = [file_id]
        json_body[&#34;updateSample&#34;] = update_sample
        json_body[&#34;passFile&#34;] = pass_filter
        json_body[&#34;outputVcfName&#34;] = output_vcf_name

        return self._ga4gh_call(
            &#34;genomicsets&#34;, json=json_body, http_verb=&#34;POST&#34;
        )
    else:
        json_body[&#34;fileId&#34;] = file_id

        return self._ga4gh_call(
            set_type.value, json=json_body, http_verb=&#34;POST&#34;
        )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.delete_set"><code class="name flex">
<span>def <span class="ident">delete_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, set_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>set_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The set ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_set(self, set_type: SetType, set_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a genomic set

    Parameters
    ----------
    set_type : SetType
        The set type
    set_id : str
        The set ID

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._ga4gh_call(
            f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.delete_test"><code class="name flex">
<span>def <span class="ident">delete_test</span></span>(<span>self, project_id: str, test_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a genomic test</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The project ID</dd>
<dt><strong><code>test_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The test ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_test(self, project_id: str, test_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a genomic test

    Parameters
    ----------
    project_id : SetType
        The project ID
    test_id : str
        The test ID

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._ga4gh_call(
            f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;,
            http_verb=&#34;DELETE&#34;,
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.get_set"><code class="name flex">
<span>def <span class="ident">get_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, set_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>set_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The set ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The fetch response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_set(self, set_type: SetType, set_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a genomic set

    Parameters
    ----------
    set_type : SetType
        The set type
    set_id : str
        The set ID

    Returns
    -------
    ApiResponse
        The fetch response
    &#34;&#34;&#34;
    return self._ga4gh_call(f&#34;{set_type.value}/{set_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.get_test"><code class="name flex">
<span>def <span class="ident">get_test</span></span>(<span>self, project_id: str, test_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Get test by project and test id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>test_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Test ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The get test response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_test(self, project_id: str, test_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Get test by project and test id

    Parameters
    ----------
    project_id : str
        The project ID
    test_id : str
        The Test ID

    Returns
    -------
    ApiResponse
        The get test response
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;genomics/projects/{project_id}/tests/{test_id}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.list_sets"><code class="name flex">
<span>def <span class="ident">list_sets</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, project_id: str, sequence_id: Optional[str] = None, patient_id: Optional[str] = None, status: Optional[phc.services.genomics.Genomics.Status] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = 50) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>List genomic sets</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>sequence_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>List sets by sequence ID, by default None</dd>
<dt><strong><code>patient_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>List sets by patient ID, by default None</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>Status</code>, optional</dt>
<dd>Filter sets by status, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default 50</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The list sets response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_sets(
    self,
    set_type: SetType,
    project_id: str,
    sequence_id: Optional[str] = None,
    patient_id: Optional[str] = None,
    status: Optional[Status] = None,
    next_page_token: Optional[str] = None,
    page_size: Optional[int] = 50,
) -&gt; ApiResponse:
    &#34;&#34;&#34;List genomic sets

    Parameters
    ----------
    set_type : SetType
        The set type
    project_id : str
        The project ID
    sequence_id : str, optional
        List sets by sequence ID, by default None
    patient_id : str, optional
        List sets by patient ID, by default None
    status : Status, optional
        Filter sets by status, by default None
    next_page_token : str, optional
        The next page token, by default None
    page_size : int, optional
        The page size, by default 50

    Returns
    -------
    ApiResponse
        The list sets response
    &#34;&#34;&#34;

    json_body = {
        &#34;datasetIds&#34;: [project_id],
        &#34;status&#34;: status,
        &#34;patientId&#34;: patient_id,
        &#34;sequenceId&#34;: sequence_id,
        &#34;pageSize&#34;: page_size,
        &#34;pageToken&#34;: next_page_token,
    }

    return self._ga4gh_call(
        f&#34;{set_type.value}/search&#34;, json=json_body, http_verb=&#34;POST&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.list_tests"><code class="name flex">
<span>def <span class="ident">list_tests</span></span>(<span>self, project_id: str, patient_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>List tests for a patient</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>patient_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The patient ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The list tests response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_tests(self, project_id: str, patient_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;List tests for a patient

    Parameters
    ----------
    project_id : str
        The project ID
    patient_id : str
        The patient ID

    Returns
    -------
    ApiResponse
        The list tests response
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;genomics/projects/{project_id}/subjects/{patient_id}/tests&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Genomics.update_set"><code class="name flex">
<span>def <span class="ident">update_set</span></span>(<span>self, set_type: phc.services.genomics.Genomics.SetType, set_id: str, updates: dict) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Update a genomic set</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_type</code></strong> :&ensp;<code>SetType</code></dt>
<dd>The set type</dd>
<dt><strong><code>set_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The set ID</dd>
<dt><strong><code>updates</code></strong> :&ensp;<code>dict</code></dt>
<dd>The updates to apply</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The fetch response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_set(
    self, set_type: SetType, set_id: str, updates: dict
) -&gt; ApiResponse:
    &#34;&#34;&#34;Update a genomic set

    Parameters
    ----------
    set_type : SetType
        The set type
    set_id : str
        The set ID
    updates : dict
        The updates to apply

    Returns
    -------
    ApiResponse
        The fetch response
    &#34;&#34;&#34;
    return self._ga4gh_call(
        f&#34;{set_type.value}/{set_id}&#34;, json=updates, http_verb=&#34;PATCH&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.PatientML"><code class="flex name class">
<span>class <span class="ident">PatientML</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Base client for making API requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PatientML(BaseClient):
    def create_model(self, body: ModelConfigInput):
        &#34;&#34;&#34;Creates a new model via a model config object.&#34;&#34;&#34;
        res = self._api_call(
            api_path=&#34;/v1/patient-ml/models&#34;,
            http_verb=&#34;POST&#34;,
            json=json.loads(body.json(exclude_none=True)),
        )
        return CreateModelResponse.parse_obj(res.data)

    def get_models(self):
        &#34;&#34;&#34;Gets all model configs for an account.&#34;&#34;&#34;
        res = self._api_call(api_path=&#34;/v1/patient-ml/models&#34;, http_verb=&#34;GET&#34;)
        return GetModelsResponse.parse_obj(res.data)

    def update_model(self, id: str, body: ModelConfigInput):
        &#34;&#34;&#34;Updates a model config.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{id}&#34;,
            http_verb=&#34;PUT&#34;,
            json=json.loads(body.json(exclude_none=True)),
        )
        return UpdateModelResponse.parse_obj(res.data)

    def delete_model(self, id: str):
        &#34;&#34;&#34;Deletes a model.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{id}&#34;, http_verb=&#34;DELETE&#34;
        )
        return DeleteModelResponse.parse_obj(res.data)

    def get_model(self, id: str):
        &#34;&#34;&#34;Gets a model config.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{id}&#34;, http_verb=&#34;GET&#34;
        )
        return GetModelResponse.parse_obj(res.data)

    def create_run(self, model_id: str):
        &#34;&#34;&#34;Begins a new ML run for a given model.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/runs&#34;, http_verb=&#34;POST&#34;
        )
        return CreateRunResponse.parse_obj(res.data)

    def get_runs(self, model_id: str):
        &#34;&#34;&#34;Gets data for all ML runs for a model.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/runs&#34;, http_verb=&#34;GET&#34;
        )
        return GetRunsResponse.parse_obj(res.data)

    def get_run(self, model_id: str, run_id: str):
        &#34;&#34;&#34;Gets data for a particular run.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}&#34;,
            http_verb=&#34;GET&#34;,
        )
        return GetRunResponse.parse_obj(res.data)

    def get_model_artifact(self, model_id: str, run_id: str):
        &#34;&#34;&#34;Gets a url that can be used to download the model artifact for a particular run.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}/model-artifact&#34;,
            http_verb=&#34;GET&#34;,
        )
        return GetModelArtifactResponse.parse_obj(res.data)

    def get_model_logs(
        self, model_id: str, run_id: str, params: GetModelLogsParams
    ):
        &#34;&#34;&#34;Gets the log events for a particular run.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}/logs&#34;,
            http_verb=&#34;GET&#34;,
            params=json.loads(params.json(exclude_none=True)),
        )
        return GetModelLogsResponse.parse_obj(res.data)

    def create_approval_decision(
        self, model_id: str, run_id: str, body: CreateApprovalDecisionRequest
    ):
        &#34;&#34;&#34;Adds a new approval decision to a model run.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}/approvals&#34;,
            http_verb=&#34;POST&#34;,
            json=json.loads(body.json(exclude_none=True)),
        )
        return CreateApprovalDecisionResponse.parse_obj(res.data)

    def get_examples(self, model_id: str, params: GetExamplesParams):
        &#34;&#34;&#34;Fetches a page of training data examples for data labeling.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/examples&#34;,
            http_verb=&#34;GET&#34;,
            params=json.loads(params.json(exclude_none=True)),
        )
        return GetExamplesResponse.parse_obj(res.data)

    def get_example(
        self, model_id: str, example_id: str, params: GetExampleParams
    ):
        &#34;&#34;&#34;Fetches a single training data example for data labeling.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}&#34;,
            http_verb=&#34;GET&#34;,
            params=json.loads(params.json(exclude_none=True)),
        )
        return GetExampleResponse.parse_obj(res.data)

    def put_label(self, model_id: str, example_id: str, body: Label):
        &#34;&#34;&#34;Updates the label for a training data example&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}/label&#34;,
            http_verb=&#34;PUT&#34;,
            json=json.loads(body.json(exclude_none=True)),
        )
        return Example.parse_obj(res.data)

    def get_label_file(self, model_id: str, example_id: str):
        &#34;&#34;&#34;Retrieves the label file for the given example, if it exists, and converts it to the format LabelStudio expects.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}/label-file&#34;,
            http_verb=&#34;GET&#34;,
        )
        return GetLabelFileResponse.parse_obj(res.data)

    def put_label_file(
        self, model_id: str, example_id: str, body: LabelFileData
    ):
        &#34;&#34;&#34;Preprocesses the label data and updates the label file for a training data example. This is done for ML problem types that store their labels as independent files, such as image segmentation. For those problem types, The label data is not stored on a label FHIR record, but in a separate file-service file, and pointed to by a label FHIR record.&#34;&#34;&#34;
        res = self._api_call(
            api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}/label-file&#34;,
            http_verb=&#34;PUT&#34;,
            json=json.loads(body.json(exclude_none=True)),
        )
        return PutLabelFileResponse.parse_obj(res.data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.PatientML.create_approval_decision"><code class="name flex">
<span>def <span class="ident">create_approval_decision</span></span>(<span>self, model_id: str, run_id: str, body: phc.services.patient_ml.CreateApprovalDecisionRequest)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new approval decision to a model run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_approval_decision(
    self, model_id: str, run_id: str, body: CreateApprovalDecisionRequest
):
    &#34;&#34;&#34;Adds a new approval decision to a model run.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}/approvals&#34;,
        http_verb=&#34;POST&#34;,
        json=json.loads(body.json(exclude_none=True)),
    )
    return CreateApprovalDecisionResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.create_model"><code class="name flex">
<span>def <span class="ident">create_model</span></span>(<span>self, body: phc.services.patient_ml.ModelConfigInput)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new model via a model config object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_model(self, body: ModelConfigInput):
    &#34;&#34;&#34;Creates a new model via a model config object.&#34;&#34;&#34;
    res = self._api_call(
        api_path=&#34;/v1/patient-ml/models&#34;,
        http_verb=&#34;POST&#34;,
        json=json.loads(body.json(exclude_none=True)),
    )
    return CreateModelResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.create_run"><code class="name flex">
<span>def <span class="ident">create_run</span></span>(<span>self, model_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Begins a new ML run for a given model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_run(self, model_id: str):
    &#34;&#34;&#34;Begins a new ML run for a given model.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/runs&#34;, http_verb=&#34;POST&#34;
    )
    return CreateRunResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.delete_model"><code class="name flex">
<span>def <span class="ident">delete_model</span></span>(<span>self, id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_model(self, id: str):
    &#34;&#34;&#34;Deletes a model.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{id}&#34;, http_verb=&#34;DELETE&#34;
    )
    return DeleteModelResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_example"><code class="name flex">
<span>def <span class="ident">get_example</span></span>(<span>self, model_id: str, example_id: str, params: phc.services.patient_ml.GetExampleParams)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches a single training data example for data labeling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_example(
    self, model_id: str, example_id: str, params: GetExampleParams
):
    &#34;&#34;&#34;Fetches a single training data example for data labeling.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}&#34;,
        http_verb=&#34;GET&#34;,
        params=json.loads(params.json(exclude_none=True)),
    )
    return GetExampleResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_examples"><code class="name flex">
<span>def <span class="ident">get_examples</span></span>(<span>self, model_id: str, params: phc.services.patient_ml.GetExamplesParams)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches a page of training data examples for data labeling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_examples(self, model_id: str, params: GetExamplesParams):
    &#34;&#34;&#34;Fetches a page of training data examples for data labeling.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/examples&#34;,
        http_verb=&#34;GET&#34;,
        params=json.loads(params.json(exclude_none=True)),
    )
    return GetExamplesResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_label_file"><code class="name flex">
<span>def <span class="ident">get_label_file</span></span>(<span>self, model_id: str, example_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the label file for the given example, if it exists, and converts it to the format LabelStudio expects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label_file(self, model_id: str, example_id: str):
    &#34;&#34;&#34;Retrieves the label file for the given example, if it exists, and converts it to the format LabelStudio expects.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}/label-file&#34;,
        http_verb=&#34;GET&#34;,
    )
    return GetLabelFileResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self, id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a model config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self, id: str):
    &#34;&#34;&#34;Gets a model config.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{id}&#34;, http_verb=&#34;GET&#34;
    )
    return GetModelResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_model_artifact"><code class="name flex">
<span>def <span class="ident">get_model_artifact</span></span>(<span>self, model_id: str, run_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a url that can be used to download the model artifact for a particular run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_artifact(self, model_id: str, run_id: str):
    &#34;&#34;&#34;Gets a url that can be used to download the model artifact for a particular run.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}/model-artifact&#34;,
        http_verb=&#34;GET&#34;,
    )
    return GetModelArtifactResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_model_logs"><code class="name flex">
<span>def <span class="ident">get_model_logs</span></span>(<span>self, model_id: str, run_id: str, params: phc.services.patient_ml.GetModelLogsParams)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the log events for a particular run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model_logs(
    self, model_id: str, run_id: str, params: GetModelLogsParams
):
    &#34;&#34;&#34;Gets the log events for a particular run.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}/logs&#34;,
        http_verb=&#34;GET&#34;,
        params=json.loads(params.json(exclude_none=True)),
    )
    return GetModelLogsResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_models"><code class="name flex">
<span>def <span class="ident">get_models</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all model configs for an account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_models(self):
    &#34;&#34;&#34;Gets all model configs for an account.&#34;&#34;&#34;
    res = self._api_call(api_path=&#34;/v1/patient-ml/models&#34;, http_verb=&#34;GET&#34;)
    return GetModelsResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_run"><code class="name flex">
<span>def <span class="ident">get_run</span></span>(<span>self, model_id: str, run_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets data for a particular run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_run(self, model_id: str, run_id: str):
    &#34;&#34;&#34;Gets data for a particular run.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/runs/{run_id}&#34;,
        http_verb=&#34;GET&#34;,
    )
    return GetRunResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.get_runs"><code class="name flex">
<span>def <span class="ident">get_runs</span></span>(<span>self, model_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets data for all ML runs for a model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runs(self, model_id: str):
    &#34;&#34;&#34;Gets data for all ML runs for a model.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/runs&#34;, http_verb=&#34;GET&#34;
    )
    return GetRunsResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.put_label"><code class="name flex">
<span>def <span class="ident">put_label</span></span>(<span>self, model_id: str, example_id: str, body: phc.services.patient_ml.Label)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the label for a training data example</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_label(self, model_id: str, example_id: str, body: Label):
    &#34;&#34;&#34;Updates the label for a training data example&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}/label&#34;,
        http_verb=&#34;PUT&#34;,
        json=json.loads(body.json(exclude_none=True)),
    )
    return Example.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.put_label_file"><code class="name flex">
<span>def <span class="ident">put_label_file</span></span>(<span>self, model_id: str, example_id: str, body: phc.services.patient_ml.LabelFileData)</span>
</code></dt>
<dd>
<div class="desc"><p>Preprocesses the label data and updates the label file for a training data example. This is done for ML problem types that store their labels as independent files, such as image segmentation. For those problem types, The label data is not stored on a label FHIR record, but in a separate file-service file, and pointed to by a label FHIR record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_label_file(
    self, model_id: str, example_id: str, body: LabelFileData
):
    &#34;&#34;&#34;Preprocesses the label data and updates the label file for a training data example. This is done for ML problem types that store their labels as independent files, such as image segmentation. For those problem types, The label data is not stored on a label FHIR record, but in a separate file-service file, and pointed to by a label FHIR record.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{model_id}/examples/{example_id}/label-file&#34;,
        http_verb=&#34;PUT&#34;,
        json=json.loads(body.json(exclude_none=True)),
    )
    return PutLabelFileResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
<dt id="phc.services.PatientML.update_model"><code class="name flex">
<span>def <span class="ident">update_model</span></span>(<span>self, id: str, body: phc.services.patient_ml.ModelConfigInput)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a model config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_model(self, id: str, body: ModelConfigInput):
    &#34;&#34;&#34;Updates a model config.&#34;&#34;&#34;
    res = self._api_call(
        api_path=f&#34;/v1/patient-ml/models/{id}&#34;,
        http_verb=&#34;PUT&#34;,
        json=json.loads(body.json(exclude_none=True)),
    )
    return UpdateModelResponse.parse_obj(res.data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Projects"><code class="flex name class">
<span>class <span class="ident">Projects</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC projects</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Projects(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC projects

    Parameters
    ----------
    session : phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def create(self, name: str, description: str = None) -&gt; ApiResponse:
        &#34;&#34;&#34;Creates a project

        Parameters
        ----------
        name : str
            The project name.
        description : str, optional
            The project description, by default None

        Returns
        -------
        phc.ApiResponse
            The create project response
        &#34;&#34;&#34;
        json_body = {&#34;name&#34;: name}
        if description:
            json_body[&#34;description&#34;] = description
        return self._api_call(&#34;projects&#34;, json=json_body, http_verb=&#34;POST&#34;)

    def get(self, project_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a project by id

        Parameters
        ----------
        project_id : str
            The project ID.

        Returns
        -------
        phc.ApiResponse
            The get project response
        &#34;&#34;&#34;
        return self._api_call(f&#34;projects/{project_id}&#34;, http_verb=&#34;GET&#34;)

    def update(
        self, project_id: str, name: str, description: Optional[str] = None
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Update a project

        Parameters
        ----------
         project_id : str
            The project ID.
        name : str
            The project name.
        description : str, optional
            The project description, by default None

        Returns
        -------
        phc.ApiResponse
            The update project response
        &#34;&#34;&#34;
        json_body = {&#34;name&#34;: name}
        if description:
            json_body[&#34;description&#34;] = description
        return self._api_call(
            f&#34;projects/{project_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
        ).data

    def delete(self, project_id: str) -&gt; bool:
        &#34;&#34;&#34;Delete a project

        Parameters
        ----------
        project_id : str
            The project ID.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        return (
            self._api_call(
                f&#34;projects/{project_id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 204
        )

    def get_list(
        self,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of projects in an account

        Parameters
        ----------
        page_size : int, optional
            The page size, by default None
        next_page_token : str, optional
            The next page token, by default None
        name : str, optional
            A project name filter, by default None

        Returns
        -------
        phc.ApiResponse
            The list projects response
        &#34;&#34;&#34;
        query_dict = {}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if name:
            query_dict[&#34;name&#34;] = name
        return self._api_call(
            f&#34;projects?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Projects.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, name: str, description: str = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The project name.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The project description, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The create project response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, name: str, description: str = None) -&gt; ApiResponse:
    &#34;&#34;&#34;Creates a project

    Parameters
    ----------
    name : str
        The project name.
    description : str, optional
        The project description, by default None

    Returns
    -------
    phc.ApiResponse
        The create project response
    &#34;&#34;&#34;
    json_body = {&#34;name&#34;: name}
    if description:
        json_body[&#34;description&#34;] = description
    return self._api_call(&#34;projects&#34;, json=json_body, http_verb=&#34;POST&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, project_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, project_id: str) -&gt; bool:
    &#34;&#34;&#34;Delete a project

    Parameters
    ----------
    project_id : str
        The project ID.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    return (
        self._api_call(
            f&#34;projects/{project_id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 204
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, project_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a project by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get project response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, project_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a project by id

    Parameters
    ----------
    project_id : str
        The project ID.

    Returns
    -------
    phc.ApiResponse
        The get project response
    &#34;&#34;&#34;
    return self._api_call(f&#34;projects/{project_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, page_size: Optional[int] = None, next_page_token: Optional[str] = None, name: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of projects in an account</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A project name filter, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list projects response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    page_size: Optional[int] = None,
    next_page_token: Optional[str] = None,
    name: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of projects in an account

    Parameters
    ----------
    page_size : int, optional
        The page size, by default None
    next_page_token : str, optional
        The next page token, by default None
    name : str, optional
        A project name filter, by default None

    Returns
    -------
    phc.ApiResponse
        The list projects response
    &#34;&#34;&#34;
    query_dict = {}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if name:
        query_dict[&#34;name&#34;] = name
    return self._api_call(
        f&#34;projects?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Projects.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, project_id: str, name: str, description: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Update a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>project_id : str</dt>
<dt>The project ID.</dt>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The project name.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The project description, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The update project response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(
    self, project_id: str, name: str, description: Optional[str] = None
) -&gt; ApiResponse:
    &#34;&#34;&#34;Update a project

    Parameters
    ----------
     project_id : str
        The project ID.
    name : str
        The project name.
    description : str, optional
        The project description, by default None

    Returns
    -------
    phc.ApiResponse
        The update project response
    &#34;&#34;&#34;
    json_body = {&#34;name&#34;: name}
    if description:
        json_body[&#34;description&#34;] = description
    return self._api_call(
        f&#34;projects/{project_id}&#34;, json=json_body, http_verb=&#34;PATCH&#34;
    ).data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Tasks"><code class="flex name class">
<span>class <span class="ident">Tasks</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides access to PHC Tasks</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session.</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False).</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30).</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tasks(BaseClient):
    &#34;&#34;&#34;Provides access to PHC Tasks

    Parameters
    ----------
    session: phc.Session
        The PHC session.
    run_async: bool
        True to return promises, False to return results (default is False).
    timeout: int
        Operation timeout (default is 30).
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default).
    &#34;&#34;&#34;

    def get(self, task_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a task by id

        Parameters
        ----------
        task_id: str
            The task ID.

        Returns
        -------
        phc.ApiResponse
            The get task response.
        &#34;&#34;&#34;
        return self._api_call(f&#34;tasks/{task_id}&#34;, http_verb=&#34;GET&#34;)

    def retry(self, task_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Retry a task by id

        Parameters
        ----------
        task_id: str
            The task ID.

        Returns
        -------
        phc.ApiResponse
            The retry task response.
        &#34;&#34;&#34;
        return self._api_call(f&#34;tasks/{task_id}:clone&#34;)

    def cancel(self, task_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Cancel a task by id

        Parameters
        ----------
        task_id: str
            The task ID.

        Returns
        -------
        phc.ApiResponse
            The cancel task response.
        &#34;&#34;&#34;
        return self._api_call(f&#34;tasks/{task_id}:cancel&#34;)

    def create(self, task: dict) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a task

        Parameters
        ----------
        task: dict
            The task to create.

        Returns
        -------
        phc.ApiResponse
            The create task response.
        &#34;&#34;&#34;
        return self._api_call(&#34;tasks&#34;, json=task)

    def list(
        self,
        project_id: str,
        prefix: Optional[str] = None,
        state: Optional[str] = None,
        minimal: Optional[bool] = None,
        page_size: Optional[int] = None,
        next_page_token: Optional[str] = None,
    ):
        &#34;&#34;&#34;Fetch a list of tasks in a project

        Parameters
        ----------
        project_id: str
            The project ID for the tasks.
        prefix: str, optional
            The prefix to filter tasks by, by default None.
        state: str, optional
            The state to filter tasks by, by default None.
        bool: bool, optional
            Set to True to just get task state, by default None.
        page_size: int, optional
            The page size, by default None.
        next_page_token: str, optional
            The next page token, by default None.

        Returns
        -------
        phc.ApiResponse
            The list tasks response.
        &#34;&#34;&#34;
        query_dict: Dict[str, Union[str, int]] = {}
        query_dict[&#34;datasetId&#34;] = project_id
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token
        if prefix:
            query_dict[&#34;name&#34;] = prefix
        if state:
            query_dict[&#34;state&#34;] = state
        if minimal:
            query_dict[&#34;view&#34;] = &#34;MINIMAL&#34;

        return self._api_call(f&#34;tasks?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Tasks.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, task_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel a task by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>task_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The task ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The cancel task response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, task_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Cancel a task by id

    Parameters
    ----------
    task_id: str
        The task ID.

    Returns
    -------
    phc.ApiResponse
        The cancel task response.
    &#34;&#34;&#34;
    return self._api_call(f&#34;tasks/{task_id}:cancel&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Tasks.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, task: dict) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a task</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code>dict</code></dt>
<dd>The task to create.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The create task response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, task: dict) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a task

    Parameters
    ----------
    task: dict
        The task to create.

    Returns
    -------
    phc.ApiResponse
        The create task response.
    &#34;&#34;&#34;
    return self._api_call(&#34;tasks&#34;, json=task)</code></pre>
</details>
</dd>
<dt id="phc.services.Tasks.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, task_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a task by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>task_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The task ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get task response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, task_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a task by id

    Parameters
    ----------
    task_id: str
        The task ID.

    Returns
    -------
    phc.ApiResponse
        The get task response.
    &#34;&#34;&#34;
    return self._api_call(f&#34;tasks/{task_id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Tasks.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self, project_id: str, prefix: Optional[str] = None, state: Optional[str] = None, minimal: Optional[bool] = None, page_size: Optional[int] = None, next_page_token: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of tasks in a project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID for the tasks.</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The prefix to filter tasks by, by default None.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The state to filter tasks by, by default None.</dd>
<dt><strong><code>bool</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set to True to just get task state, by default None.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default None.</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list tasks response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(
    self,
    project_id: str,
    prefix: Optional[str] = None,
    state: Optional[str] = None,
    minimal: Optional[bool] = None,
    page_size: Optional[int] = None,
    next_page_token: Optional[str] = None,
):
    &#34;&#34;&#34;Fetch a list of tasks in a project

    Parameters
    ----------
    project_id: str
        The project ID for the tasks.
    prefix: str, optional
        The prefix to filter tasks by, by default None.
    state: str, optional
        The state to filter tasks by, by default None.
    bool: bool, optional
        Set to True to just get task state, by default None.
    page_size: int, optional
        The page size, by default None.
    next_page_token: str, optional
        The next page token, by default None.

    Returns
    -------
    phc.ApiResponse
        The list tasks response.
    &#34;&#34;&#34;
    query_dict: Dict[str, Union[str, int]] = {}
    query_dict[&#34;datasetId&#34;] = project_id
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token
    if prefix:
        query_dict[&#34;name&#34;] = prefix
    if state:
        query_dict[&#34;state&#34;] = state
    if minimal:
        query_dict[&#34;view&#34;] = &#34;MINIMAL&#34;

    return self._api_call(f&#34;tasks?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Tasks.retry"><code class="name flex">
<span>def <span class="ident">retry</span></span>(<span>self, task_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Retry a task by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>task_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The task ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The retry task response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry(self, task_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Retry a task by id

    Parameters
    ----------
    task_id: str
        The task ID.

    Returns
    -------
    phc.ApiResponse
        The retry task response.
    &#34;&#34;&#34;
    return self._api_call(f&#34;tasks/{task_id}:clone&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Tools"><code class="flex name class">
<span>class <span class="ident">Tools</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC tools registry</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tools(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC tools registry

    Parameters
    ----------
    session: phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def create(
        self,
        name: str,
        description: str,
        access: ToolAccess,
        version: str,
        tool_class: ToolClass,
        source: str,
        labels: Optional[List[str]] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a tool.

        Parameters
        ----------
        name: str
            The name to give to the tool
        description: str
            A description of the tool
        access: ToolAccess
            The access level given to the tool [PRIVATE, ACCOUNT, PHC, PUBLIC]
        version: str
            The initial version of the tool
        tool_class: ToolClass
            The class of the tool [Workflow, Notebook]
        source: str
            The path of the tool to upload
        labels: List[str], optional
            A list of labels to apply to the tool, i.e. [&#34;bam&#34;,&#34;samtools&#34;]

        Returns
        -------
        ApiResponse
            The create tool response

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Tools
        &gt;&gt;&gt; tools = Tools(session)
        &gt;&gt;&gt; tools.create(name=&#34;Read Depth Notebook&#34;, description=&#34;Generates a chart of positional read depth from a bam file&#34;,
              access=&#34;PHC&#34;, version=&#34;1.0.0&#34;, tool_class=&#34;Notebook&#34;, source=&#34;./mynotebook.ipynb&#34;, labels=[&#34;bam&#34;,&#34;samtools]&#34;)
        &#34;&#34;&#34;
        if not hasattr(ToolClass, tool_class):
            raise ValueError(
                f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
            )

        if not hasattr(ToolAccess, access):
            raise ValueError(
                f&#34;{access} is not a valid Tool Class value {[e.value for e in ToolAccess]}&#34;
            )

        create_request = {
            &#34;version&#34;: version,
            &#34;access&#34;: access,
            &#34;name&#34;: name,
            &#34;toolClassId&#34;: ToolClassIdMappings[tool_class],
            &#34;descriptorType&#34;: DescriptorTypeMappings[tool_class],
            &#34;description&#34;: description,
        }
        if labels:
            create_request[&#34;labels&#34;] = labels

        res = self._api_call(
            &#34;/v1/trs/v2/tools&#34;, json=create_request, http_verb=&#34;POST&#34;
        )

        upload_request = {
            &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
            &#34;toolId&#34;: res[&#34;id&#34;],
            &#34;version&#34;: res[&#34;meta_version&#34;],
        }

        upload_response = self._api_call(
            &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
        )
        file_size = os.path.getsize(source)
        self._api_call_impl(
            http_verb=&#34;PUT&#34;,
            url=upload_response[&#34;uploadUrl&#34;],
            api_path=None,
            upload_file=source,
            headers={
                &#34;Content-Length&#34;: str(file_size),
                &#34;Authorization&#34;: None,
                &#34;LifeOmic-Account&#34;: None,
                &#34;Content-Type&#34;: None,
            },
        )
        return res

    @backoff.on_exception(
        backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
    )
    def download(
        self,
        tool_id: str,
        version: Optional[str] = None,
        dest_dir: Optional[str] = os.getcwd(),
    ) -&gt; None:
        &#34;&#34;&#34;Download a tool

        Parameters
        ----------
        tool_id : str
            The tool ID
        version : str, optional
            The version.
        dest_dir : str, optional
            The local directory to save the tool.  Defaults to the current working directory

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Tools
        &gt;&gt;&gt; tools = Tools(session)
        &gt;&gt;&gt; tools.download(tool_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
        &#34;&#34;&#34;
        id = f&#34;{tool_id}:{version}&#34; if version else tool_id
        res = self._api_call(f&#34;/v1/trs/files/{id}/download&#34;, http_verb=&#34;GET&#34;)

        file_path = os.path.join(dest_dir, res.get(&#34;fileName&#34;))
        target_dir = os.path.dirname(file_path)
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)

        urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
        return file_path

    def get(self, tool_id: str, version: Optional[str] = None) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a tool by id

        Parameters
        ----------
        tool_id : str
            The tool ID.
        version : str, optional
            The version.

        Returns
        -------
        phc.ApiResponse
            The get tool response
        &#34;&#34;&#34;
        id = f&#34;{tool_id}:{version}&#34; if version else tool_id
        return self._api_call(f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;GET&#34;)

    def add_version(
        self,
        tool_id: str,
        version: str,
        source: str,
        is_default: Optional[bool] = False,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Adds a new version to a tool.

        Parameters
        ----------
        tool_id : str
            The tool ID to add the version to.
        version : str
            The new version for the tool.
        source: str
            The path of the version to upload.
        is_default: bool = False
            Updates default setting for the tool.

        Returns
        -------
        phc.ApiResponse
            The updated tool response
        &#34;&#34;&#34;
        version_request = {&#34;version&#34;: version, &#34;isDefault&#34;: is_default}

        res = self._api_call(
            f&#34;/v1/trs/v2/tools/{tool_id}/versions&#34;,
            json=version_request,
            http_verb=&#34;POST&#34;,
        )
        upload_request = {
            &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
            &#34;toolId&#34;: res[&#34;id&#34;],
            &#34;version&#34;: res[&#34;meta_version&#34;],
        }

        upload_response = self._api_call(
            &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
        )
        file_size = os.path.getsize(source)
        self._api_call_impl(
            http_verb=&#34;PUT&#34;,
            url=upload_response[&#34;uploadUrl&#34;],
            api_path=None,
            upload_file=source,
            headers={
                &#34;Content-Length&#34;: str(file_size),
                &#34;Authorization&#34;: None,
                &#34;LifeOmic-Account&#34;: None,
                &#34;Content-Type&#34;: None,
            },
        )
        return res

    def delete(self, tool_id: str, version: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;Deletes a tool

        Parameters
        ----------
        tool_id : str
            The tool ID.
        version : str, optional
            The version.

        Returns
        -------
        bool
            True if the delete succeeeds, otherwise False
        &#34;&#34;&#34;
        id = f&#34;{tool_id}:{version}&#34; if version else tool_id
        return (
            self._api_call(
                f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;DELETE&#34;
            ).status_code
            == 200
        )

    def get_list(
        self,
        tool_class: Optional[ToolClass] = None,
        organization: Optional[str] = None,
        tool_name: Optional[str] = None,
        author: Optional[str] = None,
        labels: Optional[List[str]] = None,
        page_size: Optional[int] = 1000,
        page_count: Optional[int] = 0,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of tools from the registry

        Parameters
        ----------
        tool_class: str, optional
            The class of the tool, by default None
        organization: str, optional
            The organization that owns the tool, by default None
        tool_name: str, optional
            The name of the tool, by default None
        author: str, optional
            The creator of the tool, by default None
        labels: List[str], optional
            A list of labels describing the tool, by default None
        page_size: int, optional
            The count of tools to return in a single request, by default 1000
        page_count: int, optional
            The page count to return, by default 0

        Returns
        -------
        phc.ApiResponse
            The list files response
        &#34;&#34;&#34;
        query_dict = {&#34;limit&#34;: page_size, &#34;offset&#34;: page_count}
        if tool_class:
            if not hasattr(ToolClass, tool_class):
                raise ValueError(
                    f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
                )
            query_dict[&#34;toolClass&#34;] = tool_class
        if organization:
            query_dict[&#34;organization&#34;] = organization
        if tool_name:
            query_dict[&#34;toolname&#34;] = tool_name
        if author:
            query_dict[&#34;author&#34;] = author
        if labels:
            query_dict[&#34;label&#34;] = &#34;,&#34;.join(labels)

        return self._api_call(
            f&#34;/v1/trs/v2/tools?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Tools.add_version"><code class="name flex">
<span>def <span class="ident">add_version</span></span>(<span>self, tool_id: str, version: str, source: str, is_default: Optional[bool] = False) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new version to a tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID to add the version to.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>The new version for the tool.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the version to upload.</dd>
<dt><strong><code>is_default</code></strong> :&ensp;<code>bool = False</code></dt>
<dd>Updates default setting for the tool.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The updated tool response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_version(
    self,
    tool_id: str,
    version: str,
    source: str,
    is_default: Optional[bool] = False,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Adds a new version to a tool.

    Parameters
    ----------
    tool_id : str
        The tool ID to add the version to.
    version : str
        The new version for the tool.
    source: str
        The path of the version to upload.
    is_default: bool = False
        Updates default setting for the tool.

    Returns
    -------
    phc.ApiResponse
        The updated tool response
    &#34;&#34;&#34;
    version_request = {&#34;version&#34;: version, &#34;isDefault&#34;: is_default}

    res = self._api_call(
        f&#34;/v1/trs/v2/tools/{tool_id}/versions&#34;,
        json=version_request,
        http_verb=&#34;POST&#34;,
    )
    upload_request = {
        &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
        &#34;toolId&#34;: res[&#34;id&#34;],
        &#34;version&#34;: res[&#34;meta_version&#34;],
    }

    upload_response = self._api_call(
        &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
    )
    file_size = os.path.getsize(source)
    self._api_call_impl(
        http_verb=&#34;PUT&#34;,
        url=upload_response[&#34;uploadUrl&#34;],
        api_path=None,
        upload_file=source,
        headers={
            &#34;Content-Length&#34;: str(file_size),
            &#34;Authorization&#34;: None,
            &#34;LifeOmic-Account&#34;: None,
            &#34;Content-Type&#34;: None,
        },
    )
    return res</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, name: str, description: str, access: phc.services.tools.ToolAccess, version: str, tool_class: phc.services.tools.ToolClass, source: str, labels: Optional[List[str]] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name to give to the tool</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A description of the tool</dd>
<dt><strong><code>access</code></strong> :&ensp;<code>ToolAccess</code></dt>
<dd>The access level given to the tool [PRIVATE, ACCOUNT, PHC, PUBLIC]</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>The initial version of the tool</dd>
<dt><strong><code>tool_class</code></strong> :&ensp;<code>ToolClass</code></dt>
<dd>The class of the tool [Workflow, Notebook]</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the tool to upload</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>A list of labels to apply to the tool, i.e. ["bam","samtools"]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The create tool response</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Tools
&gt;&gt;&gt; tools = Tools(session)
&gt;&gt;&gt; tools.create(name=&quot;Read Depth Notebook&quot;, description=&quot;Generates a chart of positional read depth from a bam file&quot;,
      access=&quot;PHC&quot;, version=&quot;1.0.0&quot;, tool_class=&quot;Notebook&quot;, source=&quot;./mynotebook.ipynb&quot;, labels=[&quot;bam&quot;,&quot;samtools]&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(
    self,
    name: str,
    description: str,
    access: ToolAccess,
    version: str,
    tool_class: ToolClass,
    source: str,
    labels: Optional[List[str]] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a tool.

    Parameters
    ----------
    name: str
        The name to give to the tool
    description: str
        A description of the tool
    access: ToolAccess
        The access level given to the tool [PRIVATE, ACCOUNT, PHC, PUBLIC]
    version: str
        The initial version of the tool
    tool_class: ToolClass
        The class of the tool [Workflow, Notebook]
    source: str
        The path of the tool to upload
    labels: List[str], optional
        A list of labels to apply to the tool, i.e. [&#34;bam&#34;,&#34;samtools&#34;]

    Returns
    -------
    ApiResponse
        The create tool response

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Tools
    &gt;&gt;&gt; tools = Tools(session)
    &gt;&gt;&gt; tools.create(name=&#34;Read Depth Notebook&#34;, description=&#34;Generates a chart of positional read depth from a bam file&#34;,
          access=&#34;PHC&#34;, version=&#34;1.0.0&#34;, tool_class=&#34;Notebook&#34;, source=&#34;./mynotebook.ipynb&#34;, labels=[&#34;bam&#34;,&#34;samtools]&#34;)
    &#34;&#34;&#34;
    if not hasattr(ToolClass, tool_class):
        raise ValueError(
            f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
        )

    if not hasattr(ToolAccess, access):
        raise ValueError(
            f&#34;{access} is not a valid Tool Class value {[e.value for e in ToolAccess]}&#34;
        )

    create_request = {
        &#34;version&#34;: version,
        &#34;access&#34;: access,
        &#34;name&#34;: name,
        &#34;toolClassId&#34;: ToolClassIdMappings[tool_class],
        &#34;descriptorType&#34;: DescriptorTypeMappings[tool_class],
        &#34;description&#34;: description,
    }
    if labels:
        create_request[&#34;labels&#34;] = labels

    res = self._api_call(
        &#34;/v1/trs/v2/tools&#34;, json=create_request, http_verb=&#34;POST&#34;
    )

    upload_request = {
        &#34;fileName&#34;: source.split(&#34;/&#34;).pop(),
        &#34;toolId&#34;: res[&#34;id&#34;],
        &#34;version&#34;: res[&#34;meta_version&#34;],
    }

    upload_response = self._api_call(
        &#34;/v1/trs/files&#34;, json=upload_request, http_verb=&#34;POST&#34;
    )
    file_size = os.path.getsize(source)
    self._api_call_impl(
        http_verb=&#34;PUT&#34;,
        url=upload_response[&#34;uploadUrl&#34;],
        api_path=None,
        upload_file=source,
        headers={
            &#34;Content-Length&#34;: str(file_size),
            &#34;Authorization&#34;: None,
            &#34;LifeOmic-Account&#34;: None,
            &#34;Content-Type&#34;: None,
        },
    )
    return res</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, tool_id: str, version: Optional[str] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a tool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the delete succeeeds, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, tool_id: str, version: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;Deletes a tool

    Parameters
    ----------
    tool_id : str
        The tool ID.
    version : str, optional
        The version.

    Returns
    -------
    bool
        True if the delete succeeeds, otherwise False
    &#34;&#34;&#34;
    id = f&#34;{tool_id}:{version}&#34; if version else tool_id
    return (
        self._api_call(
            f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;DELETE&#34;
        ).status_code
        == 200
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, tool_id: str, version: Optional[str] = None, dest_dir: Optional[str] = '/home/runner/work/phc-sdk-py/phc-sdk-py') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download a tool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The version.</dd>
<dt><strong><code>dest_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The local directory to save the tool.
Defaults to the current working directory</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Tools
&gt;&gt;&gt; tools = Tools(session)
&gt;&gt;&gt; tools.download(tool_id=&quot;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&quot;, dest_dir=&quot;./mydata&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@backoff.on_exception(
    backoff.expo, OSError, max_tries=6, jitter=backoff.full_jitter
)
def download(
    self,
    tool_id: str,
    version: Optional[str] = None,
    dest_dir: Optional[str] = os.getcwd(),
) -&gt; None:
    &#34;&#34;&#34;Download a tool

    Parameters
    ----------
    tool_id : str
        The tool ID
    version : str, optional
        The version.
    dest_dir : str, optional
        The local directory to save the tool.  Defaults to the current working directory

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Tools
    &gt;&gt;&gt; tools = Tools(session)
    &gt;&gt;&gt; tools.download(tool_id=&#34;db3e09e9-1ecd-4976-aa5e-70ac7ada0cc3&#34;, dest_dir=&#34;./mydata&#34;)
    &#34;&#34;&#34;
    id = f&#34;{tool_id}:{version}&#34; if version else tool_id
    res = self._api_call(f&#34;/v1/trs/files/{id}/download&#34;, http_verb=&#34;GET&#34;)

    file_path = os.path.join(dest_dir, res.get(&#34;fileName&#34;))
    target_dir = os.path.dirname(file_path)
    if not os.path.exists(target_dir):
        os.makedirs(target_dir)

    urlretrieve(res.get(&#34;downloadUrl&#34;), file_path)
    return file_path</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, tool_id: str, version: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a tool by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool ID.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The version.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get tool response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, tool_id: str, version: Optional[str] = None) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a tool by id

    Parameters
    ----------
    tool_id : str
        The tool ID.
    version : str, optional
        The version.

    Returns
    -------
    phc.ApiResponse
        The get tool response
    &#34;&#34;&#34;
    id = f&#34;{tool_id}:{version}&#34; if version else tool_id
    return self._api_call(f&#34;/v1/trs/v2/tools/{id}&#34;, http_verb=&#34;GET&#34;)</code></pre>
</details>
</dd>
<dt id="phc.services.Tools.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, tool_class: Optional[phc.services.tools.ToolClass] = None, organization: Optional[str] = None, tool_name: Optional[str] = None, author: Optional[str] = None, labels: Optional[List[str]] = None, page_size: Optional[int] = 1000, page_count: Optional[int] = 0) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of tools from the registry</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tool_class</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The class of the tool, by default None</dd>
<dt><strong><code>organization</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The organization that owns the tool, by default None</dd>
<dt><strong><code>tool_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the tool, by default None</dd>
<dt><strong><code>author</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The creator of the tool, by default None</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>A list of labels describing the tool, by default None</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The count of tools to return in a single request, by default 1000</dd>
<dt><strong><code>page_count</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page count to return, by default 0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list files response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    tool_class: Optional[ToolClass] = None,
    organization: Optional[str] = None,
    tool_name: Optional[str] = None,
    author: Optional[str] = None,
    labels: Optional[List[str]] = None,
    page_size: Optional[int] = 1000,
    page_count: Optional[int] = 0,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of tools from the registry

    Parameters
    ----------
    tool_class: str, optional
        The class of the tool, by default None
    organization: str, optional
        The organization that owns the tool, by default None
    tool_name: str, optional
        The name of the tool, by default None
    author: str, optional
        The creator of the tool, by default None
    labels: List[str], optional
        A list of labels describing the tool, by default None
    page_size: int, optional
        The count of tools to return in a single request, by default 1000
    page_count: int, optional
        The page count to return, by default 0

    Returns
    -------
    phc.ApiResponse
        The list files response
    &#34;&#34;&#34;
    query_dict = {&#34;limit&#34;: page_size, &#34;offset&#34;: page_count}
    if tool_class:
        if not hasattr(ToolClass, tool_class):
            raise ValueError(
                f&#34;{tool_class} is not a valid Tool Class value {[e.value for e in ToolClass]}&#34;
            )
        query_dict[&#34;toolClass&#34;] = tool_class
    if organization:
        query_dict[&#34;organization&#34;] = organization
    if tool_name:
        query_dict[&#34;toolname&#34;] = tool_name
    if author:
        query_dict[&#34;author&#34;] = author
    if labels:
        query_dict[&#34;label&#34;] = &#34;,&#34;.join(labels)

    return self._api_call(
        f&#34;/v1/trs/v2/tools?{urlencode(query_dict)}&#34;, http_verb=&#34;GET&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phc.services.Workflows"><code class="flex name class">
<span>class <span class="ident">Workflows</span></span>
<span>(</span><span>session: phc.session.Session, run_async: bool = False, timeout: int = 30, trust_env: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides acccess to PHC Workflows</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>session</code></strong> :&ensp;<code><a title="phc.Session" href="../index.html#phc.Session">Session</a></code></dt>
<dd>The PHC session</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code></dt>
<dd>True to return promises, False to return results (default is False)</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Operation timeout (default is 30)</dd>
<dt><strong><code>trust_env</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Workflows(BaseClient):
    &#34;&#34;&#34;Provides acccess to PHC Workflows

    Parameters
    ----------
    session: phc.Session
        The PHC session
    run_async: bool
        True to return promises, False to return results (default is False)
    timeout: int
        Operation timeout (default is 30)
    trust_env: bool
        Get proxies information from HTTP_PROXY / HTTPS_PROXY environment variables if the parameter is True (False by default)
    &#34;&#34;&#34;

    def run(
        self,
        project_id: str,
        name: str,
        tool: str,
        workflow_inputs: Optional[str] = None,
        workflow_inputs_file_id: Optional[str] = None,
        output_project_folder: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Create a tool.

        Parameters
        ----------
        project_id: str
            The project ID
        name: str
            The name to give to this run of a tool
        tool: str
            The tool id or organization/name of the tool to run
        workflow_inputs: str, optional
            The inputs required by the workflow as a json string, either this or workflow_inputs_file_id are required
        workflow_inputs_file_id: str, optional
            The inputs required by the workflow as provided in a file in PHC, either this or workflow_inputs are required
        output_project_folder: str, optional
            The destination output folder in PHC for the workflow run outputs

        Returns
        -------
        ApiResponse
            The workflow run response

        Examples
        --------
        &gt;&gt;&gt; from phc.services import Workflows
        &gt;&gt;&gt; workflows = Workflows(session)
        &gt;&gt;&gt; workflows.run(project_id=&#34;d2876f48-724f-4987-9cf0-92c7ef99a9fa&#34;,
              name=&#34;Ashion ingest subj: 2405&#34;,
              tool=&#34;lifeomic/ashion-ingest-workflow&#34;,
              workflow_inputs=&#34;{&#39;reference&#39;: &#39;GRCh37&#39;,&#39;tarFile&#39;: {&#39;class&#39;: &#39;File&#39;,&#39;fileId&#39;: &#39;28235c74-9731-4496-bb3c-41c361f106f3&#39;}, &#39;source&#39;: &#39;incoming/ashion_C043_9999_009990_T1_K1ID2_ps20190814000000.tar.gz&#39;}&#34;)
        &#34;&#34;&#34;
        create_request = {
            &#34;datasetId&#34;: project_id,
            &#34;name&#34;: name,
            &#34;workflowSourceFileId&#34;: tool,
        }

        if workflow_inputs:
            create_request[&#34;workflowInputs&#34;] = workflow_inputs
        elif workflow_inputs_file_id:
            create_request[&#34;workflowInputsFileId&#34;] = workflow_inputs_file_id
        else:
            raise ValueError(
                &#34;Must provide a value for the workflow_inputs or workflow_inputs_file_id&#34;
            )

        if output_project_folder:
            create_request[&#34;outputProjectFolder&#34;] = output_project_folder

        res = self._api_call(
            &#34;/v1/workflows/ga4gh/wes/runs&#34;,
            json=create_request,
            http_verb=&#34;POST&#34;,
        )
        return res

    def get(self, project_id: str, workflow_id: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Get workflow metadata by id

        Parameters
        ----------
        project_id: str
            The project ID
        workflow_id : str
            The workflow ID.

        Returns
        -------
        phc.ApiResponse
            The get workflow response
        &#34;&#34;&#34;
        return self._api_call(
            f&#34;/v1/workflows/ga4gh/wes/runs/{project_id}:{workflow_id}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def get_list(
        self,
        project_id: str,
        page_size: Optional[int] = 100,
        next_page_token: Optional[str] = None,
    ) -&gt; ApiResponse:
        &#34;&#34;&#34;Fetch a list of workflows run in the specified project

        Parameters
        ----------
        project_id: str
            The project ID
        page_size : int, optional
            The page size, by default 100
        next_page_token : str, optional
            The next page token, by default None

        Returns
        -------
        phc.ApiResponse
            The list workflow run response
        &#34;&#34;&#34;
        query_dict = {&#34;datasetId&#34;: project_id}
        if page_size:
            query_dict[&#34;pageSize&#34;] = page_size
        if next_page_token:
            query_dict[&#34;nextPageToken&#34;] = next_page_token

        return self._api_call(
            f&#34;/v1/workflows/ga4gh/wes/runs?{urlencode(query_dict)}&#34;,
            http_verb=&#34;GET&#34;,
        )

    def describe(self, project_id: str, tool: str) -&gt; ApiResponse:
        &#34;&#34;&#34;Returns a description of the inputs the workflow engine requires for the given tool

        Parameters
        ----------
        project_id: str
            The project ID
        tool: str
            The tool id or organization/name of the tool to run

        Returns
        -------
        phc.ApiResponse
            The description of the inputs for the given tool
        &#34;&#34;&#34;
        describe_request = {
            &#34;datasetId&#34;: project_id,
            &#34;workflowSourceFileId&#34;: tool,
        }

        return self._api_call(
            &#34;/v1/workflows/ga4gh/wes/runs/parse&#34;,
            json=describe_request,
            http_verb=&#34;POST&#34;,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phc.base_client.BaseClient</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phc.services.Workflows.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self, project_id: str, tool: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a description of the inputs the workflow engine requires for the given tool</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>tool</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool id or organization/name of the tool to run</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The description of the inputs for the given tool</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, project_id: str, tool: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Returns a description of the inputs the workflow engine requires for the given tool

    Parameters
    ----------
    project_id: str
        The project ID
    tool: str
        The tool id or organization/name of the tool to run

    Returns
    -------
    phc.ApiResponse
        The description of the inputs for the given tool
    &#34;&#34;&#34;
    describe_request = {
        &#34;datasetId&#34;: project_id,
        &#34;workflowSourceFileId&#34;: tool,
    }

    return self._api_call(
        &#34;/v1/workflows/ga4gh/wes/runs/parse&#34;,
        json=describe_request,
        http_verb=&#34;POST&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Workflows.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, project_id: str, workflow_id: str) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Get workflow metadata by id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>workflow_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The workflow ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The get workflow response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, project_id: str, workflow_id: str) -&gt; ApiResponse:
    &#34;&#34;&#34;Get workflow metadata by id

    Parameters
    ----------
    project_id: str
        The project ID
    workflow_id : str
        The workflow ID.

    Returns
    -------
    phc.ApiResponse
        The get workflow response
    &#34;&#34;&#34;
    return self._api_call(
        f&#34;/v1/workflows/ga4gh/wes/runs/{project_id}:{workflow_id}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Workflows.get_list"><code class="name flex">
<span>def <span class="ident">get_list</span></span>(<span>self, project_id: str, page_size: Optional[int] = 100, next_page_token: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a list of workflows run in the specified project</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The page size, by default 100</dd>
<dt><strong><code>next_page_token</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The next page token, by default None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phc.ApiResponse" href="../index.html#phc.ApiResponse">ApiResponse</a></code></dt>
<dd>The list workflow run response</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list(
    self,
    project_id: str,
    page_size: Optional[int] = 100,
    next_page_token: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Fetch a list of workflows run in the specified project

    Parameters
    ----------
    project_id: str
        The project ID
    page_size : int, optional
        The page size, by default 100
    next_page_token : str, optional
        The next page token, by default None

    Returns
    -------
    phc.ApiResponse
        The list workflow run response
    &#34;&#34;&#34;
    query_dict = {&#34;datasetId&#34;: project_id}
    if page_size:
        query_dict[&#34;pageSize&#34;] = page_size
    if next_page_token:
        query_dict[&#34;nextPageToken&#34;] = next_page_token

    return self._api_call(
        f&#34;/v1/workflows/ga4gh/wes/runs?{urlencode(query_dict)}&#34;,
        http_verb=&#34;GET&#34;,
    )</code></pre>
</details>
</dd>
<dt id="phc.services.Workflows.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, project_id: str, name: str, tool: str, workflow_inputs: Optional[str] = None, workflow_inputs_file_id: Optional[str] = None, output_project_folder: Optional[str] = None) ‑> phc.api_response.ApiResponse</span>
</code></dt>
<dd>
<div class="desc"><p>Create a tool.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The project ID</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name to give to this run of a tool</dd>
<dt><strong><code>tool</code></strong> :&ensp;<code>str</code></dt>
<dd>The tool id or organization/name of the tool to run</dd>
<dt><strong><code>workflow_inputs</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The inputs required by the workflow as a json string, either this or workflow_inputs_file_id are required</dd>
<dt><strong><code>workflow_inputs_file_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The inputs required by the workflow as provided in a file in PHC, either this or workflow_inputs are required</dd>
<dt><strong><code>output_project_folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The destination output folder in PHC for the workflow run outputs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ApiResponse</code></dt>
<dd>The workflow run response</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from phc.services import Workflows
&gt;&gt;&gt; workflows = Workflows(session)
&gt;&gt;&gt; workflows.run(project_id=&quot;d2876f48-724f-4987-9cf0-92c7ef99a9fa&quot;,
      name=&quot;Ashion ingest subj: 2405&quot;,
      tool=&quot;lifeomic/ashion-ingest-workflow&quot;,
      workflow_inputs=&quot;{'reference': 'GRCh37','tarFile': {'class': 'File','fileId': '28235c74-9731-4496-bb3c-41c361f106f3'}, 'source': 'incoming/ashion_C043_9999_009990_T1_K1ID2_ps20190814000000.tar.gz'}&quot;)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(
    self,
    project_id: str,
    name: str,
    tool: str,
    workflow_inputs: Optional[str] = None,
    workflow_inputs_file_id: Optional[str] = None,
    output_project_folder: Optional[str] = None,
) -&gt; ApiResponse:
    &#34;&#34;&#34;Create a tool.

    Parameters
    ----------
    project_id: str
        The project ID
    name: str
        The name to give to this run of a tool
    tool: str
        The tool id or organization/name of the tool to run
    workflow_inputs: str, optional
        The inputs required by the workflow as a json string, either this or workflow_inputs_file_id are required
    workflow_inputs_file_id: str, optional
        The inputs required by the workflow as provided in a file in PHC, either this or workflow_inputs are required
    output_project_folder: str, optional
        The destination output folder in PHC for the workflow run outputs

    Returns
    -------
    ApiResponse
        The workflow run response

    Examples
    --------
    &gt;&gt;&gt; from phc.services import Workflows
    &gt;&gt;&gt; workflows = Workflows(session)
    &gt;&gt;&gt; workflows.run(project_id=&#34;d2876f48-724f-4987-9cf0-92c7ef99a9fa&#34;,
          name=&#34;Ashion ingest subj: 2405&#34;,
          tool=&#34;lifeomic/ashion-ingest-workflow&#34;,
          workflow_inputs=&#34;{&#39;reference&#39;: &#39;GRCh37&#39;,&#39;tarFile&#39;: {&#39;class&#39;: &#39;File&#39;,&#39;fileId&#39;: &#39;28235c74-9731-4496-bb3c-41c361f106f3&#39;}, &#39;source&#39;: &#39;incoming/ashion_C043_9999_009990_T1_K1ID2_ps20190814000000.tar.gz&#39;}&#34;)
    &#34;&#34;&#34;
    create_request = {
        &#34;datasetId&#34;: project_id,
        &#34;name&#34;: name,
        &#34;workflowSourceFileId&#34;: tool,
    }

    if workflow_inputs:
        create_request[&#34;workflowInputs&#34;] = workflow_inputs
    elif workflow_inputs_file_id:
        create_request[&#34;workflowInputsFileId&#34;] = workflow_inputs_file_id
    else:
        raise ValueError(
            &#34;Must provide a value for the workflow_inputs or workflow_inputs_file_id&#34;
        )

    if output_project_folder:
        create_request[&#34;outputProjectFolder&#34;] = output_project_folder

    res = self._api_call(
        &#34;/v1/workflows/ga4gh/wes/runs&#34;,
        json=create_request,
        http_verb=&#34;POST&#34;,
    )
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="PHC Home" href="https://lifeomic.github.io/phc-sdk-py/">
<img src="./phc.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phc" href="../index.html">phc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phc.services.Accounts" href="#phc.services.Accounts">Accounts</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Accounts.get_list" href="#phc.services.Accounts.get_list">get_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Analytics" href="#phc.services.Analytics">Analytics</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Analytics.execute_sql" href="#phc.services.Analytics.execute_sql">execute_sql</a></code></li>
<li><code><a title="phc.services.Analytics.get_patients" href="#phc.services.Analytics.get_patients">get_patients</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Cohorts" href="#phc.services.Cohorts">Cohorts</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Cohorts.create" href="#phc.services.Cohorts.create">create</a></code></li>
<li><code><a title="phc.services.Cohorts.delete" href="#phc.services.Cohorts.delete">delete</a></code></li>
<li><code><a title="phc.services.Cohorts.get" href="#phc.services.Cohorts.get">get</a></code></li>
<li><code><a title="phc.services.Cohorts.get_list" href="#phc.services.Cohorts.get_list">get_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Fhir" href="#phc.services.Fhir">Fhir</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Fhir.dsl" href="#phc.services.Fhir.dsl">dsl</a></code></li>
<li><code><a title="phc.services.Fhir.execute_es" href="#phc.services.Fhir.execute_es">execute_es</a></code></li>
<li><code><a title="phc.services.Fhir.execute_sql" href="#phc.services.Fhir.execute_sql">execute_sql</a></code></li>
<li><code><a title="phc.services.Fhir.sql" href="#phc.services.Fhir.sql">sql</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Files" href="#phc.services.Files">Files</a></code></h4>
<ul class="two-column">
<li><code><a title="phc.services.Files.delete" href="#phc.services.Files.delete">delete</a></code></li>
<li><code><a title="phc.services.Files.download" href="#phc.services.Files.download">download</a></code></li>
<li><code><a title="phc.services.Files.exists" href="#phc.services.Files.exists">exists</a></code></li>
<li><code><a title="phc.services.Files.get" href="#phc.services.Files.get">get</a></code></li>
<li><code><a title="phc.services.Files.get_list" href="#phc.services.Files.get_list">get_list</a></code></li>
<li><code><a title="phc.services.Files.update" href="#phc.services.Files.update">update</a></code></li>
<li><code><a title="phc.services.Files.upload" href="#phc.services.Files.upload">upload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.GenomicIngestions" href="#phc.services.GenomicIngestions">GenomicIngestions</a></code></h4>
<ul class="">
<li><code><a title="phc.services.GenomicIngestions.create_caris" href="#phc.services.GenomicIngestions.create_caris">create_caris</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.create_caris_bam" href="#phc.services.GenomicIngestions.create_caris_bam">create_caris_bam</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.create_foundation" href="#phc.services.GenomicIngestions.create_foundation">create_foundation</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.create_foundation_bam" href="#phc.services.GenomicIngestions.create_foundation_bam">create_foundation_bam</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.create_nextgen" href="#phc.services.GenomicIngestions.create_nextgen">create_nextgen</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.create_vcf" href="#phc.services.GenomicIngestions.create_vcf">create_vcf</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.get" href="#phc.services.GenomicIngestions.get">get</a></code></li>
<li><code><a title="phc.services.GenomicIngestions.list" href="#phc.services.GenomicIngestions.list">list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Genomics" href="#phc.services.Genomics">Genomics</a></code></h4>
<ul class="two-column">
<li><code><a title="phc.services.Genomics.create_set" href="#phc.services.Genomics.create_set">create_set</a></code></li>
<li><code><a title="phc.services.Genomics.delete_set" href="#phc.services.Genomics.delete_set">delete_set</a></code></li>
<li><code><a title="phc.services.Genomics.delete_test" href="#phc.services.Genomics.delete_test">delete_test</a></code></li>
<li><code><a title="phc.services.Genomics.get_set" href="#phc.services.Genomics.get_set">get_set</a></code></li>
<li><code><a title="phc.services.Genomics.get_test" href="#phc.services.Genomics.get_test">get_test</a></code></li>
<li><code><a title="phc.services.Genomics.list_sets" href="#phc.services.Genomics.list_sets">list_sets</a></code></li>
<li><code><a title="phc.services.Genomics.list_tests" href="#phc.services.Genomics.list_tests">list_tests</a></code></li>
<li><code><a title="phc.services.Genomics.update_set" href="#phc.services.Genomics.update_set">update_set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.PatientML" href="#phc.services.PatientML">PatientML</a></code></h4>
<ul class="">
<li><code><a title="phc.services.PatientML.create_approval_decision" href="#phc.services.PatientML.create_approval_decision">create_approval_decision</a></code></li>
<li><code><a title="phc.services.PatientML.create_model" href="#phc.services.PatientML.create_model">create_model</a></code></li>
<li><code><a title="phc.services.PatientML.create_run" href="#phc.services.PatientML.create_run">create_run</a></code></li>
<li><code><a title="phc.services.PatientML.delete_model" href="#phc.services.PatientML.delete_model">delete_model</a></code></li>
<li><code><a title="phc.services.PatientML.get_example" href="#phc.services.PatientML.get_example">get_example</a></code></li>
<li><code><a title="phc.services.PatientML.get_examples" href="#phc.services.PatientML.get_examples">get_examples</a></code></li>
<li><code><a title="phc.services.PatientML.get_label_file" href="#phc.services.PatientML.get_label_file">get_label_file</a></code></li>
<li><code><a title="phc.services.PatientML.get_model" href="#phc.services.PatientML.get_model">get_model</a></code></li>
<li><code><a title="phc.services.PatientML.get_model_artifact" href="#phc.services.PatientML.get_model_artifact">get_model_artifact</a></code></li>
<li><code><a title="phc.services.PatientML.get_model_logs" href="#phc.services.PatientML.get_model_logs">get_model_logs</a></code></li>
<li><code><a title="phc.services.PatientML.get_models" href="#phc.services.PatientML.get_models">get_models</a></code></li>
<li><code><a title="phc.services.PatientML.get_run" href="#phc.services.PatientML.get_run">get_run</a></code></li>
<li><code><a title="phc.services.PatientML.get_runs" href="#phc.services.PatientML.get_runs">get_runs</a></code></li>
<li><code><a title="phc.services.PatientML.put_label" href="#phc.services.PatientML.put_label">put_label</a></code></li>
<li><code><a title="phc.services.PatientML.put_label_file" href="#phc.services.PatientML.put_label_file">put_label_file</a></code></li>
<li><code><a title="phc.services.PatientML.update_model" href="#phc.services.PatientML.update_model">update_model</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Projects" href="#phc.services.Projects">Projects</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Projects.create" href="#phc.services.Projects.create">create</a></code></li>
<li><code><a title="phc.services.Projects.delete" href="#phc.services.Projects.delete">delete</a></code></li>
<li><code><a title="phc.services.Projects.get" href="#phc.services.Projects.get">get</a></code></li>
<li><code><a title="phc.services.Projects.get_list" href="#phc.services.Projects.get_list">get_list</a></code></li>
<li><code><a title="phc.services.Projects.update" href="#phc.services.Projects.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Tasks" href="#phc.services.Tasks">Tasks</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Tasks.cancel" href="#phc.services.Tasks.cancel">cancel</a></code></li>
<li><code><a title="phc.services.Tasks.create" href="#phc.services.Tasks.create">create</a></code></li>
<li><code><a title="phc.services.Tasks.get" href="#phc.services.Tasks.get">get</a></code></li>
<li><code><a title="phc.services.Tasks.list" href="#phc.services.Tasks.list">list</a></code></li>
<li><code><a title="phc.services.Tasks.retry" href="#phc.services.Tasks.retry">retry</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Tools" href="#phc.services.Tools">Tools</a></code></h4>
<ul class="two-column">
<li><code><a title="phc.services.Tools.add_version" href="#phc.services.Tools.add_version">add_version</a></code></li>
<li><code><a title="phc.services.Tools.create" href="#phc.services.Tools.create">create</a></code></li>
<li><code><a title="phc.services.Tools.delete" href="#phc.services.Tools.delete">delete</a></code></li>
<li><code><a title="phc.services.Tools.download" href="#phc.services.Tools.download">download</a></code></li>
<li><code><a title="phc.services.Tools.get" href="#phc.services.Tools.get">get</a></code></li>
<li><code><a title="phc.services.Tools.get_list" href="#phc.services.Tools.get_list">get_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phc.services.Workflows" href="#phc.services.Workflows">Workflows</a></code></h4>
<ul class="">
<li><code><a title="phc.services.Workflows.describe" href="#phc.services.Workflows.describe">describe</a></code></li>
<li><code><a title="phc.services.Workflows.get" href="#phc.services.Workflows.get">get</a></code></li>
<li><code><a title="phc.services.Workflows.get_list" href="#phc.services.Workflows.get_list">get_list</a></code></li>
<li><code><a title="phc.services.Workflows.run" href="#phc.services.Workflows.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
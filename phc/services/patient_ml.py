# This file was generated automatically. Do not edit it directly.
import json

from phc.base_client import BaseClient

# generated by datamodel-codegen:
#   filename:  patient-ml-service.json


from typing import List, Optional, Union

from pydantic import BaseModel, Extra, Field
from typing_extensions import Literal


class MlProblemDefinitionBase(BaseModel):
    class Config:
        extra = Extra.allow

    retrainEvery: Optional[float] = None
    """
    If provided, the model will automatically be retrained if this many milliseconds have passed since the last run. Models will not be retrained more frequently than once per day, and this policy is only checked once per day, so more than this many milliseconds may actually pass before the model is retrained.
    """


class LabelDefinitionBase(BaseModel):
    class Config:
        extra = Extra.allow

    id: Optional[str] = None
    """
    UUID uniquely identifying this label.
    """
    name: str
    """
    The unique name of the label.
    """
    description: str


class LabelDefinition(LabelDefinitionBase):
    id: str
    index: int = Field(..., ge=0, le=255)
    """
    The unique integer identifying this label, in the range [0,255]. It must never change during the life of the model because it is stored in training data as the label's identifier.
    """


class LabelsDefinitionInput(BaseModel):
    class Config:
        extra = Extra.allow

    labels: List[LabelDefinitionBase]


class LabelsDefinition(BaseModel):
    class Config:
        extra = Extra.forbid

    labels: List[LabelDefinition]
    maxLabelIndex: int = Field(..., ge=-1, le=255)
    """
    The maximum index used by any label defined for this model over the life of the model. This field cannot be set by a user but is used to track what label indices have already been exhausted.
    """


class ClassificationProblemInput(MlProblemDefinitionBase):
    labelDefinition: LabelsDefinitionInput


class ClassificationProblem(MlProblemDefinitionBase):
    labelDefinition: LabelsDefinition


class ImageSegmentationArea(BaseModel):
    """
    A run-length encoded (RLE) 4 channel color image, representing the mask for a single label.
    """

    class Config:
        extra = Extra.forbid

    id: str
    """
    The ID of the label this mask is for.
    """
    rle: List[int]
    """
    The run-length encoded mask; an array of 8-bit unsigned integers.
    """


class ImageSegmentationLabelData(BaseModel):
    """
    A raw image segmentation, in the format LabelStudio provides.
    """

    class Config:
        extra = Extra.forbid

    labelType: Literal["imgSeg"]
    projectId: str
    """
    The ID of the LifeOmic project the label file is saved under.
    """
    height: int
    """
    The height of the segmentation mask in pixels.
    """
    width: int
    """
    The width of the segmentation mask in pixels.
    """
    areas: List[ImageSegmentationArea]


class LabelFileData(BaseModel):
    __root__: ImageSegmentationLabelData


class Tag(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str
    value: str


class Tags(BaseModel):
    __root__: List[Tag]


class LabelBase(BaseModel):
    class Config:
        extra = Extra.allow

    isConfirmed: Optional[bool] = None
    """
    A confirmed label is believed to be correct and may be used during training and evaluation.
    """
    lastConfirmedBy: Optional[str] = None
    """
    The email address or other identifier of the user who last confirmed this label.
    """
    updatedAt: Optional[float] = None
    """
    Timestamp for when the label was last updated or created expressed as milliseconds since the UTC epoch.
    """
    tags: Optional[Tags] = None


class Mask(BaseModel):
    """
    The fileId of an image containing per-pixel labels
    """

    class Config:
        extra = Extra.forbid

    fileId: str


class ImageSegmentationLabel(LabelBase):
    labelType: Literal["imgSeg"]
    mask: Mask
    """
    The fileId of an image containing per-pixel labels
    """


class ImageClassificationLabel(LabelBase):
    labelType: Literal["imgClf"]
    classes: List[float]
    """
    An array of integers representing the class(es) of the image
    """


class Label(BaseModel):
    __root__: Union[ImageSegmentationLabel, ImageClassificationLabel]


class ExampleBase(BaseModel):
    class Config:
        extra = Extra.allow

    id: str
    updatedAt: float
    """
    Timestamp expressed as milliseconds since the UTC epoch.
    """


class Image(BaseModel):
    class Config:
        extra = Extra.forbid

    fileId: str


class ImageSegmentationExample(ExampleBase):
    exampleType: Literal["imgSeg"]
    image: Image
    label: Optional[ImageSegmentationLabel] = None


class ImageClassificationExample(ExampleBase):
    exampleType: Literal["imgClf"]
    image: Image
    label: Optional[ImageClassificationLabel] = None


class Example(BaseModel):
    __root__: Union[ImageSegmentationExample, ImageClassificationExample]


class FhirCodesFilter(BaseModel):
    """
    Used to find FHIR resources containing a type code that equals any value in the codes array
    """

    class Config:
        extra = Extra.forbid

    filterType: Literal["FhirCodesFilter"]
    codes: List[str] = Field(..., max_items=10, min_items=1)


class CategoricalParameterSpace(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Literal["categorical"]
    name: str
    values: List[str]


class NumericScale(BaseModel):
    __root__: Literal["auto", "linear", "log", "reverseLog"]


class NumericParameterSpace(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    min: float
    max: float
    scale: NumericScale


class ContinuousParameterSpace(NumericParameterSpace):
    type: Literal["continuous"]


class IntegerParameterSpace(NumericParameterSpace):
    type: Literal["integer"]


class ParameterSpace(BaseModel):
    __root__: Union[
        CategoricalParameterSpace,
        ContinuousParameterSpace,
        IntegerParameterSpace,
    ]


class OptimizationObjective(BaseModel):
    class Config:
        extra = Extra.forbid

    direction: Literal["minimize", "maximize"]
    metric: str


class MetricDefinition(BaseModel):
    """
    Camel-cased mirror of https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_MetricDefinition.html.
    """

    class Config:
        extra = Extra.forbid

    name: str
    regex: str


class TuningJobTrainingApproach(BaseModel):
    class Config:
        extra = Extra.allow

    type: Literal["tuningJob"]
    trainingImage: str = Field(
        ...,
        regex="^[0-9]+\\.dkr.ecr.[-a-z0-9]+\\.amazonaws\\.com\\/[-_a-zA-Z0-9]+:[-_a-zA-Z0-9]+$",
    )
    """
    An aws ecr image uri of the form <account-id>.dkr.ecr.<region>.amazonaws.com/<repo-name>:<tag>
    """
    metricDefinitions: List[MetricDefinition]
    objective: OptimizationObjective
    """
    The metric to optimize during the hyperparameter tuning process.
    """
    searchSpace: List[ParameterSpace]
    """
    The hyperparameter search space to explore during hyperparameter tuning.
    """
    maxTrials: Optional[int] = Field(None, ge=1, le=30)
    """
    The maximum number of candidate models to consider in a given model run.
    """


class TrainingApproach(BaseModel):
    __root__: TuningJobTrainingApproach


class DeployApproachBase(BaseModel):
    class Config:
        extra = Extra.allow

    inferenceImage: str = Field(
        ...,
        regex="^[0-9]+\\.dkr.ecr.[-a-z0-9]+\\.amazonaws\\.com\\/[-_a-zA-Z0-9]+:[-_a-zA-Z0-9]+$",
    )
    """
    An aws ecr image uri of the form <account-id>.dkr.ecr.<region>.amazonaws.com/<repo-name>:<tag>
    """


class EdgeDeployApproach(DeployApproachBase):
    type: Literal["edge"]


class CloudDeployApproach(DeployApproachBase):
    type: Literal["cloud"]


class DeployApproach(BaseModel):
    __root__: Union[EdgeDeployApproach, CloudDeployApproach]


class EvaluationApproach(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Literal["customImage"]
    imageUri: str = Field(
        ...,
        regex="^[0-9]+\\.dkr.ecr.[-a-z0-9]+\\.amazonaws\\.com\\/[-_a-zA-Z0-9]+:[-_a-zA-Z0-9]+$",
    )
    """
    An aws ecr image uri of the form <account-id>.dkr.ecr.<region>.amazonaws.com/<repo-name>:<tag>
    """


class ModelConfigBase(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    description: str
    trainingApproach: TrainingApproach
    deployApproach: DeployApproach
    evaluationApproach: Optional[EvaluationApproach] = None


class Split(BaseModel):
    class Config:
        extra = Extra.forbid

    n: float
    """
    The number of examples in this split.
    """
    start: float
    """
    Timestamp marking the beginning of the data for this split (inclusive). Expressed as milliseconds since the UTC epoch.
    """
    end: float
    """
    Timestamp marking the end of the data for this split (exclusive). Expressed as milliseconds since the UTC epoch.
    """
    uri: str = Field(..., regex="^s3:\\/\\/.+$")
    """
    S3 URI of where a copy of this exact split is saved.
    """


class Metric(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str
    """
    The name of the metric e.g. "Cross Entopy Loss", "Accuracy", "F1 Macro", etc.
    """
    value: float
    stage: Literal["training", "evaluation"]
    """
    The stage of the model run this metric was computed in. If `training`, the metric could have been computed over the train or val set. If `evaluation`, the metric was computed over the test set.
    """


class ApprovalChoice(BaseModel):
    __root__: Literal["approved", "rejected"]


class ApprovalDecisionBase(BaseModel):
    class Config:
        extra = Extra.forbid

    timestamp: float
    """
    Timestamp of when the decision was made. Expressed as milliseconds since the UTC epoch.
    """
    decision: ApprovalChoice


class SystemApprovalDecision(ApprovalDecisionBase):
    actor: Literal["system"]


class UserApprovalDecision(ApprovalDecisionBase):
    actor: Literal["user"]
    user: str


class ApprovalDecision(BaseModel):
    __root__: Union[SystemApprovalDecision, UserApprovalDecision]


class RunSplits(BaseModel):
    """
    Information about the different splits of the dataset used to train this model version.
    """

    class Config:
        extra = Extra.forbid

    train: Split
    val: Split
    test: Split


class RunMetrics(BaseModel):
    class Config:
        extra = Extra.forbid

    challenger: List[Metric]
    """
    Metrics about how the model version trained in this run (the challenger) performed on this run's test set.
    """
    champion: List[Metric]
    """
    Metrics about how the current best model (the champion) performed on this run's test set.
    """


class Parameter(BaseModel):
    """
    A hyperparameter value. The values themselves are represented as strings.
    """

    class Config:
        extra = Extra.forbid

    name: str
    value: str


class LogEvent(BaseModel):
    """
    An event logged by some component of a model run, as well as metadata about the log event.
    """

    class Config:
        extra = Extra.forbid

    type: Literal["logEntry"]
    timestamp: float
    """
    The time when the log event occurred, expressed as milliseconds since the unix epoch.
    """
    payload: str
    """
    The actual body of the logged event.
    """
    stage: str
    """
    The model run's stage or component that produced this log event.
    """


class DeleteModelResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    id: str
    """
    The id of the model that was deleted.
    """


class CreateRunResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    runId: str
    """
    The id of the newly created run. Can be used to fetch data about the run.
    """


class GetModelArtifactResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    url: str


class GetModelLogsParams(BaseModel):
    filter: Optional[str] = None
    """
    An optional field used to filter the log events. This parameter supports AWS CloudWatch Logs' filter and pattern syntax. See https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html for instructions on how to write filters.
    """
    marker: Optional[str] = None
    """
    Passed in to control which page of results is retrieved.
    """
    limit: Optional[int] = Field(None, ge=1, le=10000)
    """
    The maximum number of events to return. The default is to return 10,000 -- the largest allowed.
    """


class GetModelLogsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    events: List[LogEvent]
    marker: Optional[str] = None
    """
    A marker used for pagination. Pass it in the request body to retrieve the next page of results. This field will be undefined if the output is not truncated.
    """


class CreateApprovalDecisionRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    choice: ApprovalChoice


class CreateApprovalDecisionResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    approvalDecision: UserApprovalDecision


class GetExamplesParams(BaseModel):
    projectId: str
    hasLabel: Optional[Literal["true", "false"]] = None
    hasUnconfirmedLabel: Optional[Literal["true", "false"]] = None
    """
    Allows for fetching examples that have unconfirmed labels.
    """
    marker: Optional[str] = None
    patientId: Optional[str] = None


class GetExamplesResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    examples: List[Example]
    marker: Optional[str] = None
    """
    A marker used for pagination. Pass it in the request body to retrieve the next page of results. This field will be undefined if the output is not truncated.
    """


class GetExampleParams(BaseModel):
    projectId: str


class GetExampleResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    example: Optional[Example] = None


class GetLabelFileResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    labelData: Optional[LabelFileData] = None


class PutLabelFileResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    fileId: str
    """
    The id of the file-service file the label file was saved to.
    """


class ImageSegmentationProblemBase(BaseModel):
    class Config:
        extra = Extra.allow

    problemType: Literal["imgSeg"]
    trainingDataFilter: FhirCodesFilter
    """
    Used to filter through patient data to identify image/mask pairs for model training.
    """


class ImageSegmentationProblemInput(
    ClassificationProblemInput, ImageSegmentationProblemBase
):
    pass


class ImageSegmentationProblem(
    ClassificationProblem, ImageSegmentationProblemBase
):
    pass


class ImageClassificationProblemBase(BaseModel):
    class Config:
        extra = Extra.allow

    problemType: Literal["imgClf"]
    trainingDataFilter: FhirCodesFilter
    """
    Used to filter through patient data to identify the input images for the model.
    """


class ImageClassificationProblemInput(
    ClassificationProblemInput, ImageClassificationProblemBase
):
    pass


class ImageClassificationProblem(
    ClassificationProblem, ImageClassificationProblemBase
):
    pass


class MlProblemDefinitionInput(BaseModel):
    __root__: Union[
        ImageSegmentationProblemInput, ImageClassificationProblemInput
    ]


class MlProblemDefinition(BaseModel):
    __root__: Union[ImageSegmentationProblem, ImageClassificationProblem]


class ModelConfigInput(ModelConfigBase):
    problemDefinition: MlProblemDefinitionInput


class ModelConfig(ModelConfigBase):
    id: str
    """
    UUID uniquely identifying this model config.
    """
    accountId: str
    problemDefinition: MlProblemDefinition
    deployedId: Optional[str] = None
    """
    The ID of the model version currently deployed for this model config.
    @deprecated use championId instead
    """
    championId: Optional[str] = None
    """
    The ID of the champion model run for this model config.
    """


class ModelRun(BaseModel):
    class Config:
        extra = Extra.forbid

    id: str
    """
    UUID uniquely identifying this model run.
    """
    slug: str
    """
    Human-readable slug that acts as an auto-generated name for the run. This field is not guaranteed to be unique, so cannot be used reliably as a unique identifier.
    """
    modelId: str
    """
    ID of the model config this run was produced for.
    """
    accountId: str
    modelArtifactUri: Optional[str] = None
    """
    S3 URI location where the final trained model artifact produced by this run is saved to.
    """
    status: Literal["running", "succeeded", "failed"]
    error: Optional[str] = None
    """
    If `status` is 'failed', gives the reason why the run failed.
    """
    deployStatus: Optional[Literal["deploying", "succeeded", "failed"]] = None
    deployError: Optional[str] = None
    """
    If `deployStatus` is 'failed', gives the reason why deploying the model endpoint failed
    """
    start: float
    """
    Timestamp of when the run started. Expressed as milliseconds since the UTC epoch.
    """
    end: Optional[float] = None
    """
    Timestamp of when the run ended. Expressed as milliseconds since the UTC epoch.
    """
    isArchived: Optional[bool] = None
    """
    True if this run has been archived. Archived runs' related artifacts are deleted, and they can no longer be deployed.
    """
    splits: Optional[RunSplits] = None
    hyperparameters: List[Parameter]
    """
    The hyperparameters used to train the model version created by this run.
    """
    championId: Optional[str] = None
    """
    The ID of the model run that was the current champion while this model run was running. All champion metrics on this model run represent that champion's performance on this run's dataset.
    """
    metrics: RunMetrics
    approvals: List[ApprovalDecision]
    """
    Decisions made by various actors representing whether they think this model version should be used in production and become the new champion.
    """
    problemDefinition: MlProblemDefinition
    trainingApproach: TrainingApproach
    deployApproach: DeployApproach
    evaluationApproach: Optional[EvaluationApproach] = None


class CreateModelResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    model: ModelConfig


class GetModelsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    models: List[ModelConfig]


class UpdateModelResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    model: ModelConfig


class GetModelResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    model: Optional[ModelConfig] = None


class GetRunsResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    runs: List[ModelRun]


class GetRunResponse(BaseModel):
    class Config:
        extra = Extra.forbid

    run: Optional[ModelRun] = None


class PatientML(BaseClient):
    def create_model(self, body: ModelConfigInput):
        """Creates a new model via a model config object."""
        res = self._api_call(
            api_path="/v1/patient-ml/models",
            http_verb="POST",
            json=json.loads(body.json(exclude_none=True)),
        )
        return CreateModelResponse.parse_obj(res.data)

    def get_models(self):
        """Gets all model configs for an account."""
        res = self._api_call(api_path="/v1/patient-ml/models", http_verb="GET")
        return GetModelsResponse.parse_obj(res.data)

    def update_model(self, id: str, body: ModelConfigInput):
        """Updates a model config."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{id}",
            http_verb="PUT",
            json=json.loads(body.json(exclude_none=True)),
        )
        return UpdateModelResponse.parse_obj(res.data)

    def delete_model(self, id: str):
        """Deletes a model."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{id}", http_verb="DELETE"
        )
        return DeleteModelResponse.parse_obj(res.data)

    def get_model(self, id: str):
        """Gets a model config."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{id}", http_verb="GET"
        )
        return GetModelResponse.parse_obj(res.data)

    def create_run(self, model_id: str):
        """Begins a new ML run for a given model."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/runs", http_verb="POST"
        )
        return CreateRunResponse.parse_obj(res.data)

    def get_runs(self, model_id: str):
        """Gets data for all ML runs for a model."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/runs", http_verb="GET"
        )
        return GetRunsResponse.parse_obj(res.data)

    def get_run(self, model_id: str, run_id: str):
        """Gets data for a particular run."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/runs/{run_id}",
            http_verb="GET",
        )
        return GetRunResponse.parse_obj(res.data)

    def get_model_artifact(self, model_id: str, run_id: str):
        """Gets a url that can be used to download the model artifact for a particular run."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/runs/{run_id}/model-artifact",
            http_verb="GET",
        )
        return GetModelArtifactResponse.parse_obj(res.data)

    def get_model_logs(
        self, model_id: str, run_id: str, params: GetModelLogsParams
    ):
        """Gets the log events for a particular run."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/runs/{run_id}/logs",
            http_verb="GET",
            params=json.loads(params.json(exclude_none=True)),
        )
        return GetModelLogsResponse.parse_obj(res.data)

    def create_approval_decision(
        self, model_id: str, run_id: str, body: CreateApprovalDecisionRequest
    ):
        """Adds a new approval decision to a model run."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/runs/{run_id}/approvals",
            http_verb="POST",
            json=json.loads(body.json(exclude_none=True)),
        )
        return CreateApprovalDecisionResponse.parse_obj(res.data)

    def get_examples(self, model_id: str, params: GetExamplesParams):
        """Fetches a page of training data examples for data labeling."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/examples",
            http_verb="GET",
            params=json.loads(params.json(exclude_none=True)),
        )
        return GetExamplesResponse.parse_obj(res.data)

    def get_example(
        self, model_id: str, example_id: str, params: GetExampleParams
    ):
        """Fetches a single training data example for data labeling."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/examples/{example_id}",
            http_verb="GET",
            params=json.loads(params.json(exclude_none=True)),
        )
        return GetExampleResponse.parse_obj(res.data)

    def put_label(self, model_id: str, example_id: str, body: Label):
        """Updates the label for a training data example"""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/examples/{example_id}/label",
            http_verb="PUT",
            json=json.loads(body.json(exclude_none=True)),
        )
        return Example.parse_obj(res.data)

    def get_label_file(self, model_id: str, example_id: str):
        """Retrieves the label file for the given example, if it exists, and converts it to the format LabelStudio expects."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/examples/{example_id}/label-file",
            http_verb="GET",
        )
        return GetLabelFileResponse.parse_obj(res.data)

    def put_label_file(
        self, model_id: str, example_id: str, body: LabelFileData
    ):
        """Preprocesses the label data and updates the label file for a training data example. This is done for ML problem types that store their labels as independent files, such as image segmentation. For those problem types, The label data is not stored on a label FHIR record, but in a separate file-service file, and pointed to by a label FHIR record."""
        res = self._api_call(
            api_path=f"/v1/patient-ml/models/{model_id}/examples/{example_id}/label-file",
            http_verb="PUT",
            json=json.loads(body.json(exclude_none=True)),
        )
        return PutLabelFileResponse.parse_obj(res.data)
